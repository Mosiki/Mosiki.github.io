[{"title":"2017年终总结","date":"2017-12-30T10:02:57.000Z","path":"2017年终总结.html","text":"前言一年时间倏然而逝，今日已是年终岁尾矣！ 总是感觉今年过得太快了，很多次下班的时候，同事说：“明天周五了”，而我的反应就是：“诶？又要放假了吗？我怎么感觉前天才上班的啊😂”。以前还在上学的时候，总是感叹，这一天天为何如此漫长呢！随着年龄的增长，仿佛时间的流速也同时加快了一般，每天总是觉得是在和时间赛跑，让我有些焦虑。 今年过的让我感觉很快，但是觉得比以前充实，因为做到的事情比以前多很多。 2017 我做了哪些事 记录 2017 整年收支从 2017 年开始，比较认真的记录了自己的日常开支情况，记账 APP 显示已经坚持 记账 575 天了。我个人记账就是为了防止自己过度消费，毕竟移动支付在中国这么发达，钱已经变成了一串数字，不注意就全花光了。上个月买了一台 MBP，用于日常学习，之前的旧电脑已经带不动 IDE 了，索性换了，真的是血贵，不过写代码真爽！有的支出就是无法避免，能做的就是减少不必要的支出；记账这件事情上，做的不太好的是虽然记录的比较详尽，但是缺少总结；来年需要做阶段性的总结，比如每个月总结一次，找出不必要支出，下次尽量避免，努力实行“开源节流”。 开始基金定投年初的时候，看了一些理财的入门书籍，基本的理财技能还是需要掌握的，于是从四月份开始走上了养基之路，目前为止只定投了一只股基，收益尚可，做的不太好的地方就是把鸡蛋都放在了同一个篮子里，明年要着手于分散投资。 记录 2017 整年时间去年看了《奇特的一生》这本书，感觉时间不够用的我，尝试学习 柳比歇夫 的时间统计法，记录自己每天的时间清单，用的是 IOS 上的 APP：「时间块」 通过软件的统计功能，比较直观了反映了我的时间都去哪儿了。自我感觉比往年用在学习上的时间要多很多，但是预料不及的是我在玩（游戏、动漫、出外游玩等花费的时间）上的投入时间和蹉跎的时间（如漫无目的地上网浏览、做无任何意义事情的时间）之和，竟然狂甩学习时间几条街😰，说明自己对于时间的利用还是太低太低。最让我震惊的是用于交通(坐车，步行，等车等)的时间，居然达到了近 850 小时！一年十二个月,其中的一个月全是在车上度过！慎思极恐！柳比歇夫在每天每个周末每个月每个季度每年他都会汇总统计自己的时间支出，核算有效时间并加以总结，这一点我确实是没做到他这么极致，也是自己需要进行改进的地方，比如以后每个月总结一次时间的消费，看看自己有没有利用好这个月。 开始早起在记录了半年的时间消费后，看了统计后，深觉时间真的不够用，于是从六月份开始早起，工作日基本每天 5 点起床。不足的地方就是早起后，到7点洗漱吃饭去上班之前的这段时间，时间的利用不是很有效率，还有就是周末有时候变得很懒，经常快拖到 8 点多才起床😓，明年努力给自己找事情，提高时间的利用效率，周末督促自己早起。 开始认真对待博客其实从 2016 年，便开始用 Hexo 搭建了博客，并开始写博客，但是当时只是好奇心的驱使，随便写写觉得有趣，所以写的很水，但是从 2017 年开始，就约束自己要认真点写，对自己写博客付出的时间进行负责。我认为对于做技术的人而言，写不写博客是两种人，写的博客好不好也是两种人。不足之处就是总的博客文章不够多，大多也没有什么深度；明年多多写博客，提升技术能力，期望可以写一些比较有深度的博客。 自学新的技术技术的更迭速度很快，为了不被淘汰，只有通过不断学习，来提高技术能力。目前所在的公司是一家以业务驱动的公司，所以平时写的业务代码比较多一些，对于新的技术接触的比较少，但是领导比较鼓励我们学习新的技术用于工作中。公司的技术一成不变往往不是公司的问题，而是我们做技术的问题，就算公司想用新的技术，但是没有人会，这种技术也就不会被引入，因为使用成本太高；但是若这项技术，我们都会，而且又很有利于公司，相信一定会得到公司推行。为了保持进步，自学新兴的技术，对于自学新技术，垂直教育网站(编程) 慕课网 很不错！学习了新的技术，在恰当的时机合适的项目进行引入，也是对自己学习成果的一种实践！ 买 Kindle 看书年初买了 Kindle 用于看书，强制自己看书；看书的过程中，越发觉得自己的阅读能力实在是太查了，很多地方都读不懂，这也坚定了我要坚持看书的想法。今年看了 25 本左右的书，但是精读的太少，很多都是囫囵吞枣，纠结于读书的数量，而不是质量，来年尽量提高阅读的质量。 2017 做的不好的地方 除了上面提出的问题，身上还有一堆等着我去克服的缺点。 下半年的时候，搞了个服务器，给电脑装上了 SS 的客户端，得以随时可以访问被墙的 Google 。于是在便利查找问题的环境下，出现了要做什么工作的时候，不去思考，而是先去进行 Google 搜索一番的情况，太过依赖 Google ，随时番羽墙对于我也不是一件好事。来年希望可以养成万事先独立思考的习惯，不要成为一名只会 Google 代码的码农。 忘了从几月份开始，王者荣耀火了，我也不出意外地陷了进去，大概玩了两三个月，之后意识到自己的做法不对，方才卸载了游戏。多亏了定力的增长，否则还可能沉迷其中不可自拔，以后就尽量不玩游戏了吧，毕竟还要那么多的知识等待着我去学呢！ 每年都会看到程序员猝死的新闻，这个行业有的公司高强度无休止的加班，加上精神压力，以及不经常锻炼身体的习惯，导致悲剧的发生。在唏嘘的同时，却没有想到自己也没有锻炼身体的习惯，幸运的是公司不加班。也曾经坚持跑步锻炼了一段时间，但是没有坚持下来，还是要制定一个锻炼的计划。 2018 我想要做的事 锻炼身体，身体好是一切活动的前提 多写博客，多精读书，多写读书笔记 独立思考，多总结，争取做一个精进的人 重新学习英语，英语能力太差了，多学点英语 拾起日语的学习 结语资源越多越浪费，资源越少越珍贵，时间亦是，周末时间很多但是利用效率却低的可怕，每天早起一个多小时，能完成周末好几个小时能完成的事情。每每浪费了光阴，在余下不多的时间里想要开始认真时，却总是在时间不够用的抱怨声里，草草结束了本次周末，所以，时间都去哪儿呢？","tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://nullpointer.pw/tags/年终总结/"}]},{"title":"mac编译安装Nginx","date":"2017-12-06T22:50:18.000Z","path":"mac编译安装nginx.html","text":"前言虽然后简单的方式安装Nginx，但是习惯了在linux 上的操作，为了保持一致，因此也使用编译安装的方法进行安装Nginx。 资源下载 nginx: http://nginx.org/download/nginx-1.12.2.tar.gz zlib: http://zlib.net/zlib-1.2.11.tar.gz pcre: ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz openssl: https://www.openssl.org/source/openssl-1.1.0g.tar.gz 这些都是 Nginx 编译需要的依赖，下载后分别解压， 注意解压的文件要在同一个目录下面 1234567tar -zxvf nginx-1.12.2.tar.gztar -zxvf zlib-1.2.11.tar.gztar -zxvf pcre-8.38.tar.gztar -zxvf openssl-1.1.0g.tar.gz 进入nginx目录后执行12345678./configure --prefix=/usr/local/nginx --with-zlib=../zlib-1.2.11 --with-pcre=../pcre-8.38 --with-openssl=../openssl-1.1.0g// 依次执行以下命令makesudo make install 以上执行完毕后， nginx 就被安装到 /usr/local/nginx 目录下 Nginx的启停在 mac 上随便修改点东西，就提示没有权限也是醉了，只好每个命令前面都加上 sudo 了 启动sudo /usr/local/nginx/sbin/nginx 关闭sudo /usr/local/nginx/sbin/nginx -s stop 重启sudo /usr/local/nginx/sbin/nginx -s reload 参考 http://blog.csdn.net/tulies/article/details/77611409","tags":[{"name":"nginx安装","slug":"nginx安装","permalink":"http://nullpointer.pw/tags/nginx安装/"}]},{"title":"利用nginx解决跨域问题","date":"2017-12-06T22:31:02.000Z","path":"利用nginx解决跨域问题.html","text":"前言最近遇到了跨域问题，结合之前【微信支付开发本地接收异步通知回调】的经验，利用 Nginx 实现了跨域。 公司之前为了解决跨域问题，用的是 iFrame，反正对于只做后端的我而言，觉得很复杂，但是现在利用 nginx 如此简单就实现了跨域，感觉还挺有成就感，哈哈！ 为什么会出现跨域问题？前人已经总结得很好了，就借鉴一下吧！ 图片来源地址： http://www.cnblogs.com/gabrielchen/p/5066120.html 我们在开发项目中遇到的跨域问题具体是这样的，公司的域名若是 www.domain.com，那么如果是发送的 Ajax 请求就不通过这个域名走了，而是通过 a.domain.com，于是便出现了跨域问题。 比如在 www.domain.com 首页中需要通过 Ajax 获取用户登录信息。 准备工作下载演示项目为了演示这个跨域问题，我创建了一个 SpringBoot 项目，便于演示，如果不会 SpringBoot 也没有关系，因为重点在于 Nginx 配置上面。 【点我下载】 提取密码: 8e68 启动演示项目因为是SpringBoot 项目，因此可以通过 java -jar 的方式直接启动，为了演示跨域，因此需要启动两个项目，这里我们用两个端口来分别启动项目。 12345## A 项目，端口设置为8080java -jar -Dserver.port=8080 demo.jar## B 项目，端口设置为8090java -jar -Dserver.port=8090 demo.jar 配置本地 Host为了演示还需要两个域名，不用真正的域名，修改本地的 Host 即可，将两个域名的 Host 都执行本地。可以使用 SwitchHosts 来方便切换。 12127.0.0.1 www.domain.com127.0.0.1 a.domain.com 配置Nginx编译安装 Nginx后， 修改 nginx.conf 配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; keepalive_timeout 65; #gzip on; upstream webServer &#123; server 127.0.0.1:8080; &#125; upstream ajaxServer &#123; server 127.0.0.1:8090; &#125; server &#123; listen 80; server_name a.domain.com; location / &#123; proxy_pass http://ajaxServer; &#125; &#125; server &#123; listen 80; server_name www.domain.com; location / &#123; proxy_pass http://webServer; &#125; &#125;&#125; 这里来详细解释一下这里的配置，a.domain.com 代理到 ajaxServer，即端口设置为 8090 的 B 项目； 12345678server &#123; listen 80; server_name a.domain.com; location / &#123; proxy_pass http://ajaxServer; &#125;&#125; 再看看 www.domain.com 的配置，反向代理到 webServer , 即端口设置为 8080 的 A 项目。 12345678server &#123; listen 80; server_name www.domain.com; location / &#123; proxy_pass http://webServer; &#125;&#125; 测试访问项目地址 http://www.domain.com/page， 进入以下页面： 当输入框不输入或者输入的是当前域名 http://www.domain.com 时，可以正常提交，不会遇到跨域问题。 当输入 http://a.domain.com 时，点击按钮进行提交，会出现跨域问题。 修改 Nginx 配置文件修改 www.domain.com 的配置 12345678910111213server &#123; listen 80; server_name www.domain.com; location /proxy/ &#123; proxy_set_header Host a.domain.com; proxy_pass http://ajaxServer/; &#125; location / &#123; proxy_pass http://webServer; &#125;&#125; 其中这里这处配置是这篇文章的关键点。意思是 http://www.domain.com/proxy/ 开头的请求将会被反向代理到 B 项目 即 http://a.domain.com 域名，proxy_set_header Host 这一行是必须的。需要注意的是，这两行的域名需要保持一致，且第二行后面必须要有一个 /，至于原因，可以参考这篇文章 proxy_pass后的url加不加/的区别1234location /proxy/ &#123; proxy_set_header Host a.domain.com; proxy_pass http://ajaxServer/;&#125; 修改之后保存配置文件，重启 Nginx1./nginx -s reload 再次测试修改提交 URL 为 http://www.domain.com/proxy 点击按钮进行提交，发现此时没有出现跨域问题。虽然提交的URL 域名是 http://www.domain.com，而请求经过 Nginx 的反向代理之后，实际上提交到了 B 项目，即 http://a.domain.com， 也可以看到 B 项目打印了输出语句 userId: 12，由此便解决了跨域问题。 资源下载文章涉及的jar文件我打成一个压缩包，可以自己下载尝试一下。 【点我下载】 提取密码: 8e68","tags":[{"name":"nginx","slug":"nginx","permalink":"http://nullpointer.pw/tags/nginx/"},{"name":"跨域问题","slug":"跨域问题","permalink":"http://nullpointer.pw/tags/跨域问题/"},{"name":"反向代理","slug":"反向代理","permalink":"http://nullpointer.pw/tags/反向代理/"}]},{"title":"java推广系统设计","date":"2017-12-03T08:06:26.000Z","path":"java推广系统设计.html","text":"前言公司新站由于运营需求，需要开发一套推广系统，用于网站用户引流，衍生出的推广套路目前便已经有四种，为了降低运营上手推广系统的难度，因此推广系统务必要便于使用，所以每种推广方式的配置需要保持足够明了简单。 聊聊推广常见的推广套路就是针对一个推广员生成推广链接，推广员然后其他用户通过推广链接点击进来注册，但是不可能推广的页面是注册页面，所以需要先记录下用户的来源。注册成功的同时，绑定用户与推广员的关系，便于日后通过用户的充值消费统计推广员的推广费用，以下为推广的简单流程图。 推广系统实现推广链接的生成整个推广流程最主要的地方就是推广链接的生成与使用，为了方便推广链接的管理，需要将生成的推广链接进行保存。首先进行推广链接表的设计。最后提供给推广员的推广链接格式如：http://m.domain.com/cp?code=xx，其中 code 的值为推广链接的 ID。 字段名称 字段类型 字段描述 id int 推广链接自增主键 title varcahr 推广标题 partner_id int 推广员ID params text 推广参数 type tinyint 推广类型 url_type tinyint URL类型 create_time timestamp 创建时间 update_time timestamp 更新时间 status tinyint 启用状态 字段解读： 我这里的 id 直接设置为了自增主键的值，当然为了安全点，也可以设置为其他的值，比如 UUID； title 对于同一个推广员，可能会生成多条推广链接，用于区别。 partner_id 这个就不必多说，表明推广链接属于哪一个推广员 params 注意这个参数类型为 text， 因为为了方便扩展业务参数，因此此字段存储的是一段 JSON，若使用 varchar 长度会不够用。业务参数在我司，可以是：赠送 VIP 天数，赠送阅读券数量，推广费用等。这个字段可以自由发挥，在绑定用户的时候获取该字段，解析成 JSON 对象，读取对应的业务参数，进行相对应的设置。 因为运营同学的脑洞一般都很大，因此推广方式会有很多种，也是为了日后分析推广效果，因此加上 type 字段用于区分推广类型，推广类型有比如： CPS推广、微信公众推广等； url_type 用于区分需要推广的页面是相对路径还是绝对路径。 status 用于标记此推广链接是否有效，比如终止推广合作，就可以设置为关闭，不再将用户绑定到此链接。 后台推广链接生成页面参考： 推广链接的跳转首先再看看推广的流程 首先用户通过点击推广链接，进入了推广的页面，我司就是小说的某一免费章节的阅读页面，之后到收费章节的时候，就会提示用户进行登录。注册的用户，如何知道是从哪一个链接过来的呢？这就需要在用户注册之前就将推广链接的标记进行存储，最好的方式就是写入 Cookie。之前公司项目写 Cookie 是在前端进行，但是运行之后，发现不太可靠，因此我们将写 Cookie 的操作放在后端进行。 推广链接地址是 http://m.domain.com/cp?code=xx，访问如下接口： 12345678910111213141516171819202122232425262728293031323334/** * 用于推广链接的统一跳转 */@RequestMapping (value = \"/cp\", method = RequestMethod.GET)public String companionRedirect(String code, HttpServletRequest request, Model m, HttpServletResponse response) &#123; try &#123; int id = Integer.parseInt(code); // 查询出推广链接记录 CompanionLink link = companionService.getCompanionLink(id); if (link != null &amp;&amp; link.getStatus() != Constants.STATUS_DELETE) &#123; JSONObject obj = JSONObject.parseObject(link.getParams()); // 获取推广页面的地址 String url = obj.getString(\"url\"); // 将 code 值即推广链接的 id 写入Cookie 中， EXP为有效期 3 天 CookieUtil.setCookie(request, response, Constants.COMPANION_COOKIE_NAME, code, EXP); // 跳转到推广页面 if (link.getUrlType() == Constants.ABS) &#123; // 绝对路径直接跳转 return \"redirect:\" + url; &#125;else &#123; // 相对路径拼接域名后跳转 return \"redirect:\" + Constants.MOBILE_SERVER_DOMAIN + url; &#125; &#125; &#125; catch (NumberFormatException e) &#123; &#125; // 出现异常，跳转到首页 return \"redirect:\" + Constants.MOBILE_SERVER_DOMAIN;&#125; 写这篇文章的时候，发现之前设计推广链接的时候有所疏漏，有的推广方式是相对路径，而有的是绝对路径。而我在代码中是通过 String 的 Contains方法是否包含域名来判断是相对的还是绝对的路径，其实没有必要，完全可以添加一个推广链接的 url 的路径类型。判断类型即可，如果是绝对路径直接跳转，否则拼接域名后跳转。 推广关系的绑定用户浏览器的 Cookie 中已经保存好了推广链接的 code 值，绑定关系就好办了，可以在用户注册的时候，读取浏览器的 Cookie，获取这个 Cookie，得到推广链接的 id, 将用户的 id 与推广的 partner_id 进行绑定，保存到绑定关系的表中即可，比如我司的赠送操作也一在绑定后执行。 至于绑定关系的表设计，主要将 partner_id 与 user_id 作为联合主键保存，其他字段如绑定时间就不用多说了吧。 后记如果你看完觉得有什么疑问，可以留言评论，有需要改进的地方也请提出，共同进步！","tags":[{"name":"推广系统","slug":"推广系统","permalink":"http://nullpointer.pw/tags/推广系统/"},{"name":"推广","slug":"推广","permalink":"http://nullpointer.pw/tags/推广/"},{"name":"链接推广","slug":"链接推广","permalink":"http://nullpointer.pw/tags/链接推广/"}]},{"title":"Maven 私服上传jar包","date":"2017-11-30T13:09:28.000Z","path":"Maven 私服上传jar包.html","text":"前言前段时间，公司开了新站，主要由我来负责新站的搭建工作，基础的系统比如登录系统，支付系统的搭建。 今天在11月末尾补上这一篇文章，不然放出去的话做不到就不好了（一个月至少两篇博客）😂 在接入支付宝支付的时候，遇到了一些问题，在此记录一下。 我们公司的之前项目接入的是支付宝 mapi 支付，这是比较早的支付接口，前一阵子，该接口的授权也到期了，我也负责后续接口的升级。 接口升级后，支付宝对其 SDK 也进行了升级，按照网站文档编写代码发现有些方法不存在，才知道是由于 项目中 SDK 的版本过低导致的。既然知道了问题，就要解决问题，于是在官网下载最新版的 SDK。 我们公司的项目全部基于 Maven 进行构建，但是官网的 SDK 只是 JAR 包，在中央仓库是没有的，因此使用的话需要上传到公司的 Maven 私服上。 环境准备 需要上传的 Jar 包，我这里是支付宝的 SDK 的 Jar 包 私服环境： Artifactory 我们公司的 maven 私服就是这货啦 上传 Jar 包到 Maven选择上传 Jar 包登录 Artifactory 后，选择 Deploy，选择要上传的 Jar 包，我这里选择上传支付宝的 SDK 的 Jar 包。 设置上传 Jar 包信息在这里选择要上传的仓库，以及设置 “GAV” 参数 由于支付宝的 Jar 包名称太长了，所以我这里精简了不必要的信息。 设置完之后，点击完成即可。 查找上传 Jar 的 Maven 坐标找到刚才保存的库，找到上传的 Jar 包 点击 对应的 pom 文件，查看 Maven 坐标 将此坐标写入 pom.xml 中即可，需要先将私服的地址写到 pom.xml 文件中。 123456&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;repos&lt;/id&gt; &lt;url&gt;http://192.168.1.222:8088/artifactory/repos&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 上传源码 Jar 包到私服仓库想要在开发时看可以查看源码的时候，需要将对应的源码 Jar 包一起上传到私服中去，与前面步骤相同，此时选择对应的源码的 Jar 包。 需要注意这里的 目标仓库与 GAV 参数保持与上面上传对应的 Jar 包保持一致。唯一不同的地方是 Classifier 为 sources。 上传成功后如图，源码包与工程包在同一级目录中。此时在项目中可以刷新 pom.xml 文件后，对应的源码就会一同下载下载下来了，可以愉快的看源码了。 End.","tags":[{"name":"Maven私服","slug":"Maven私服","permalink":"http://nullpointer.pw/tags/Maven私服/"},{"name":"jar包上传","slug":"jar包上传","permalink":"http://nullpointer.pw/tags/jar包上传/"}]},{"title":"微信支付开发本地接收异步通知回调【实战】","date":"2017-11-08T14:18:34.000Z","path":"微信支付开发本地接收异步通知回调【实战】.html","text":"前言最近在调试微信相关的接口，但是由于微信官方出于安全的考虑，对于调用接口的域名有限制。微信授权与微信支付统一下单接口在本地可以通过更改 host 的方式来调试，微信服务器也能跳转回来，但是微信支付异步通知这里；微信官方强制让设置支付授权目录，且是通过 ICP 备案的域名，因此不采取特殊手段，本地是无法接收到微信的异步通知回调请求的，只能部署到线上环境测试。 前置条件为了解决这个问题，折腾了好几天，才搞出来了，究其根本原因，还是对于 Nginx 不太熟悉。所以在此记录一下。 内网转发如果想本地进行调试，并且想让微信服务器请求回调回来，则本地必须要有一个外网域名，这里我们是用 Ngrok内网转发 来实现；Ngrok 的配置就是将本地项目的端口映射到分配的外网域名，具体配置参考官网教程文档，此处不再赘述。 我的配置是：1http://vcmq.free.ngrok.cc -&gt; 127.0.0.1:8080 配置测试支付目录前面提到了，微信支付异步通知会对支付域名目录有要求，因此，支付时的域名必须要在设置的支付域名目录下。 首先需要在 微信商户平台 中配置 商户秘钥，支付授权目录。 这里支付授权目录配置的是以后线上的支付授权目录1http://pay.domain.com/wechat/public/ 然后再加一条本地测试支付的临时授权目录，这个目录最好在本地测试完成后，进行删除。1http://pay.domain.com/wechat/testpay/ 必知的 Nginx 语法proxy_pass 后的 url 加不加 / 的区别这里列举 nginx 的 proxy_pass 语法，是为了下一步针对 nginx 的配置进行修改。 这里访问 http://127.0.0.1/proxy/test.html 测试 proxy_pass 后面的 url 加与不加 / 的区别 12345678server &#123; listen 80; server_name 127.0.0.1; location /proxy/ &#123; proxy_pass http://192.168.0.100/; &#125;&#125; 以上 location 会代理到 http://192.168.0.100/test.html 即相当于是绝对根路径，则 Nginx 不会把 location 中的路径部分代理走。 12345678server &#123; listen 80; server_name 127.0.0.1; location /proxy/ &#123; proxy_pass http://192.168.0.100; &#125;&#125; 以上 location 会代理到 http://192.168.0.100/proxy/test.html 即相当于相对路径。 代理支付域名到第三方域名知道上一步 proxy_pass 后 / 的作用后，就开始来配置支付域名指向的服务器上的 nginx 的配置文件。 12345678910111213server &#123; listen 80; server_name pay.domain.com; location /testpay/ &#123; proxy_set_header Host vcmq.free.ngrok.cc; proxy_pass http://vcmq.free.ngrok.cc/wide/; &#125; location / &#123; proxy_pass http://payServer; &#125;&#125; 配置中的 wide 是我项目的名称；注意：这里的 proxy_set_header Host 必须配置，否则进入 location 块后，会提示 tunnel pay.domain.com not found。 当访问 pay.domain.com/testpay/create 微信统一下单接口时， 会代理到 http://vcmq.free.ngrok.cc/wide/create； 需要注意的是，在统一下单接口，设置 notify_url 的值要为配置的支付授权目录，比如我的 http://pay.domain.com/testpay/notify 统一下单并完成支付完成后，微信服务器会请求统一下单接口中的 notify_url，经过服务器 nginx 进行代理后，会代理到 本地的内网转发域名异步通知回调接口 http://vcmq.free.ngrok.cc/wide/notify， 从而达到了本地接收微信支付异步通知回调请求的目的。 如果地址不在支付授权目录下，会提示当前 Url 未注册。因为是代理过去，因此地址栏的地址不会改变，这也是不能简单使用 nginx 的 rewrite 的原因。 如有疑问，可以联系我。 参考 nginx proxy_pass后的url加不加/的区别 跳转第三方域名","tags":[{"name":"实战","slug":"实战","permalink":"http://nullpointer.pw/tags/实战/"},{"name":"nginx转发","slug":"nginx转发","permalink":"http://nullpointer.pw/tags/nginx转发/"},{"name":"proxy_pass","slug":"proxy-pass","permalink":"http://nullpointer.pw/tags/proxy-pass/"},{"name":"本地接收异步通知","slug":"本地接收异步通知","permalink":"http://nullpointer.pw/tags/本地接收异步通知/"}]},{"title":"Nginx图片防盗链【实战】","date":"2017-10-29T06:28:46.000Z","path":"Nginx图片防盗链【实战】.html","text":"前言博主目前在一家原创小说网站公司工作，由于站内的作品全部是原创，于是乎不可避免地会被一些盗版网站爬取盗版，对于防盗版一直没有很好的对策，让公司很是苦恼。最近去一些盗版网站上搜索我们网站作品时，发现他们所用的封面图片的来源是我们网站的地址，即所谓的盗链，这对于我们网站服务器的带宽是一种损失，因此需要采取对应的手段应对。 环境准备这里我使用两台虚拟机 虚拟机的快速安装可以参考我另外一篇博文 CentOS快速安装 服务器 A：192.168.200.130 服务器 B：192.168.200.131 Nginx 安装参考博文 Nginx缓存配置 的 Nginx 环境搭建部分。 Nginx 防盗链设置一、配置 Nginx 的防盗链12345678910111213141516171819202122# 修改 nginx.conf 配置文件vim /usr/local/nginx/conf/nginx.conf# 添加 server 节点server &#123; listen 80; server_name www.vcmq.com; #access_log logs/host.access.log main; location ~* \\.(jpg|png|gif)$ &#123; root /home/resources; valid_referers none server_names *.test1.com ~\\.test2\\.; if ($invalid_referer)&#123; rewrite ^/ http://ojt4b2cr5.bkt.clouddn.com/blog/20171028/214345352.png; &#125; &#125; location / &#123; root html; index index.html index.htm; &#125;&#125; 可以看到，我新增的 server 的地址是 www.vcmq.com。 1location ~* \\.(jpg|png|gif)$ 此行配置的作用是匹配以 jpg/png/gif 结尾的文件请求， 如果匹配就执行 括号内的代码。1234valid_referers none server_names *.test1.com ~\\.test2\\.;if ($invalid_referer)&#123; rewrite ^/ http://ojt4b2cr5.bkt.clouddn.com/blog/20171028/214345352.png;&#125; 首先看第一行，这行的作用是配置可以识别 refer，即可以正常获取资源文件的请求，在这里配置加入白名单的请求 refer 域名。参数说明： none 代表请求的 refer 为空，也就是直接访问，比如在浏览器中直接访问图片 www.vcmq.com/test1.png，直接访问时，refer 会为空。 blocked refer 来源不为空，但是里面的值被代理或者防火墙删除了 server_names refer 来源包含当前的 server_names 即 location 的父节点 server 节点的 server_name 的值。 字符串 定义服务器名称，比如 *.test1.com，配置后，来源是从 test1.com 就会被认为是合法的请求。 正则表达式 匹配合法请求来源， 如 ~\\.test2\\. 当请求的 refer 是合法的，即可以被后面任一参数所匹配， $invalid_referer 的值为0， 若不匹配则值为 1， 进入 if 的代码中。我这里的设置是，如果是不合法的请求，就统一返回一张图片，也可以直接返回 403。 二、配置 html 文件1.在 /home 目录下创建目录 resources ,在 /home/resources 目录下放入一张图片 test.png。 2.修改 nginx 安装目录下 html 中的 index.html 文件。添加一个 img 标签，src 访问上一步中的图片文件1&lt;img src=&quot;http://www.vcmq.com/test.png&quot; /&gt; 3.启动 nginx1/usr/local/nginx/sbin/nginx 4.以上所有配置是对于服务器 A 的配置，以下讲解服务器 B 的配置 服务器 B 和 服务器 A一样安装好 nginx 修改 nginx.conf 配置文件, 添加两个 server 12345678910111213141516171819server &#123; listen 80; server_name www.test1.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125;&#125; server &#123; listen 80; server_name www.test2.com; location / &#123; root html; index index.html index.htm; &#125;&#125; 修改服务器 B Nginx 安装目录下 html 目录中的 index.html 文件,同样添加 img 标签。 1&lt;img src=&quot;http://www.vcmq.com/test.png&quot; /&gt; 启动 服务器 B 的 Nginx 配置注意事项 配置资源的 location 需要在 location / 之前。 如果在 location 或者其父节点 server 中没有配置 root 的值， 当请求时合法的时候，会 404 找不到资源文件，因此需要在 location 或者 server 节点设置 root 的值 注意调试的时候，务必使用 Ctrl + F5 进行刷新网页，因为 nginx 会缓存图片！ 测试我上面配置的 server_name 配置的域名是 www.vcmq.com ，因此测试时，需要将我电脑的 host 指向虚拟机的 ip, 可以使用 SwitchHosts 来便捷切换。 12345# 指向服务器A192.168.200.130 www.vcmq.com# 指向服务器B192.168.200.131 www.test1.com www.test2.com 浏览器访问 www.vcmq.com，图片正常加载 浏览器访问 www.test1.com 与 www.test2.com 还有直接访问图片 http://www.vcmq.com/test.png 都正常加载 修改 服务器 A 的 nginx.conf 配置文件 1valid_referers none server_names *.test1.com ~\\.test2\\.; 将此行修改为 1valid_referers none server_names; 即只允许当前 server_name 与 无 refer 的请求，其他请求都返回 rewrite 的图片, 然后重启 nginx 1/usr/local/nginx/sbin/nginx -s reload 再次分别访问 ,注意需要使用 ctrl+F5 刷新一下缓存 www.vcmq.com、www.test1.com、www.test2.com、http://www.vcmq.com/test.png。 发现只有 www.vcmq.com 与 http://www.vcmq.com/test.png 正常显示，其他请求皆返回 rewrite 的图片 同理再次修改 nginx.conf 文件, 允许来自 test1 的访问请求 1valid_referers none server_names *.test1.com; 结果发现www.test1.com可以获取正常图片，而www.test2.com还是 rewrite 之后的图片 至此，已经实现了基于 Nginx 的简单图片防盗链。 实际应用中，可以设置允许来自公司下的域名与空 refer 的请求通过。 这里允许 空 refer 的请求通过的原因是，有些合法的请求可能会没有带上 refer。 资源下载 文章涉及配置文件下载 参考文章 https://www.bbsmax.com/A/xl56LLwxzr/","tags":[{"name":"实战","slug":"实战","permalink":"http://nullpointer.pw/tags/实战/"},{"name":"图片防盗链","slug":"图片防盗链","permalink":"http://nullpointer.pw/tags/图片防盗链/"},{"name":"防盗链","slug":"防盗链","permalink":"http://nullpointer.pw/tags/防盗链/"}]},{"title":"Nginx配置资源下载目录","date":"2017-10-26T22:25:24.000Z","path":"Nginx配置资源下载目录.html","text":"之前在网上找 CentOs 的镜像的时候，发现了阿里云的这个镜像源，速度蛮快的。今天也来搭建一个类似的站，使用 nginx 作为资源下载服务器。图片详情： 安装 Nginx参考这篇教程的 Nginx 环境搭建部分 设置资源存储路径1、 资源准备 在 home 的用户目录下，建立文件夹，如 softs ,在 softs 目录中放入文件内容。 修改配置文件2、 修改 Nginx 配置文件 1vim conf/nginx.conf 添加 server 123456789101112server &#123; listen 80; server_name down.vcmq.com; #sendfile on; location / &#123; alias /home/softs/; sendfile on; autoindex on; autoindex_exact_size off; autoindex_localtime on; &#125;&#125; alias 设置为第一步中的资源目录，我这里是 /home/softs/ 3、 访问测试将本机 hosts 指向服务器，访问地址 down.vcmq.com 显示目录列表 注意不能是/root 目录下的文件路径 ，会显示403无权限","tags":[{"name":"nginx","slug":"nginx","permalink":"http://nullpointer.pw/tags/nginx/"},{"name":"资源下载","slug":"资源下载","permalink":"http://nullpointer.pw/tags/资源下载/"}]},{"title":"如何做笔记？","date":"2017-10-26T14:10:02.000Z","path":"如何记笔记？.html","text":"最近在公司开会，我分享了一些个人日常关于如何记笔记的心得，结合在网上看的相关文章，整理一下，然后做了一些补充，写出这篇博文，文章涉及工具的选择和记笔记的步骤以及记笔记的技巧与注意事项，欢迎留言探讨。 工具的选择工欲善其事必先利其器，首先说说工具的选择，好的工具会让你记笔记得心应手，拥有良好的用户体验，不好的工具则做不到这点，达不到记笔记的目的。 常见的主流云笔记有： 有道云笔记 OneNote 为知笔记 印象笔记 先说说我最熟悉的为知笔记，在一年以前，一直用的是为知笔记，记了上千的笔记，用的很不错，逢人推荐那种；但是有一天，为知笔记突然就宣布必须要付费才能继续使用，否则的话，笔记将不能同步！对应一个云笔记产品来说，没有了最最基础的同步功能，和在本地文档里写有什么区别呢？没有合适的变现方式，就完全抛弃了免费用户，给我感觉这家公司不太靠谱，所以我就转战使用有道云笔记。但是之前的笔记还在为知笔记里，懒得去转移了。所以选择笔记软件的时候也要考虑转移成本，万一一不小心产品就黄了呢！因此尽量选择大公司的成熟笔记产品。 再说说现在用的有道云笔记，用一个词来形容就是很鸡贼，以前可以导出笔记为其他笔记软件识别的格式，现在只能导出有道能识别的格式。假如是重度用户，想转移笔记，很困难。好在有道云笔记支持 MarkDown 笔记，所以我现在尽量写的笔记都用 MarkDown 方式，因为 MarkDown 格式的直接在笔记中就能直接复制走，转移笔记很轻松。MarkDown，语法很简单，可以学习一下，轻松排版，语法可以参考有道云的文档， 记笔记不需要去学习太复杂的语法, 看下面链接的第二点就可以。 有道云笔记Markdown简明版 然后说说印象笔记，是国外 EverNote 的大陆版本，其免费版只能提供两个终端同步，假如你公司登陆一个，家里登陆一个，还想要在移动设备上登录就需要付费，还有每月上传60M流量的限制，付费版一年一百多，想要最稳定的可以考虑使用。 最后说说 OneNote, 巨硬出品，但是国内 GFW 的存在，同步很慢，然后也没太弄清楚是怎么用的，和上面介绍的笔记产品组织格式不同，也没怎么会用，就不置点评了。 我推荐使用有道云笔记和印象笔记(或EverNote) 记笔记的作用最大的作用就是对抗遗忘，用好了笔记，笔记就是你的第二大脑，人的记忆力有限，我们通过记笔记来拓展。 记笔记三步走： 收集 整理 输出 以下进行详细步骤叙述： 记笔记的步骤收集第一步是确定所要写的笔记内容，即收集，收集这里我分为两部分。 收集他人的内容他人的内容指的是他人所产生的内容，比如别人写的书，博客文章，公众号文章等等，当你遇到了比如一篇你觉得写的很有道理或者对你有用的文章，觉得有保存下来的价值，你可以将其纳入你的笔记当中去。 收集自己的内容自己的内容指的是自己所产生的内容，比如突发的灵光一现，如果不立即记录下来，可能就忘掉了，然后再想的时候无论如何也记不起来了，就感觉自己错过了一个亿。所以要趁着你的想法还没有消失之前，立即记录到笔记当中去。现在人手都有一副手机，而云笔记都有其对应的移动端，记录起来很方便。 收集的诀窍有时候在某个网站看到一篇文章想要保存下来时候，一般人的做法是讲文章选择拷贝到笔记当中去，这么做是可行，但是会完全没有了排版，看起来乱糟糟的一片，所以需要借助浏览器插件或者分享功能来实现快速美观地保存。有道云笔记的谷歌浏览器插件就很好用，在手机上可以关注公众号，分享到公众号，也可以直接分享到对应的笔记 App 中，从而实现快速收集。 整理收集完的内容，只是堆叠到了你的笔记当中，如果不加以整理总结，其实和散布在网络上的文章毫无区别，对你没有任何的意义，也没有任何的价值；也许你想找笔记里面某一篇文章，但是你却死活也找不到，这种情况下记与不记都一样；正如去一座图书馆看书，但是图书馆却没有图书查阅系统，在浩渺书海中想找到一本书的困难程度可想而知！因此收集后的整理十分重要。 整理分为重新排版与分类以及加标签（在下文详谈分类与标签）： 通过浏览器插件等工具抓取保存的内容可能会与原文中的内容排版相差甚远，比如有道云笔记对于代码块的抓取排版支持就很差（其他很不错），这种情况，就需要我们自己对内容重新排版，便于以后自己查看。个人一般是新建立一个 Markdown 笔记，拷贝原文进行编排，并在文末标注文章来源链接。 良好的笔记分类有利于快速准确地定位笔记，提升效率。 一篇笔记只能放在一个分类中（对应笔记的文件夹)，但是却能够添加多个标签，我认为标签是对分类的一种补充。当分类不足以准确定位笔记，此时需要通过添加标签来弥补。 输出单单只是将内容收集，归类加标签，并不能够对自己产生很大的用处，最多的是自己想起来就去笔记中寻找，此时笔记的作用最多是充当备忘录的作用。而真正想要利用好笔记，就是需要我们来对笔记进行总结思考，来达到在头脑中深化该篇笔记的作用。 举例而言，现在你写了一篇《拆掉思维里的墙》的读书笔记，但笔记的内容只有对于书中原文的部分摘抄；其实这样的笔记作用不大，时间长了，你甚至不记得你曾经读过这本书并写过读书笔记。但是你对文章进行了思考，概括书的主要中心思想，写了自己的感受，在豆瓣上留下了书评，就算时间久了，翻看笔记也能够回想起当时自己的想法，这书也就没有白读，笔记也就没有白写。 上文提到了在豆瓣中写书评，这和写笔记进行总结思考一样都是对于知识的一种输出。输出的方式还有很多种，比如在简书上、个人博客上、CSDN、博客园等地方发表文章。 当然，也并非所有的分类下面都需要进行这三步。 细谈笔记分类与标签分类按照个人的习惯与经验，我将笔记分为了五大类，如图： 1、 收集（指的是上图中的我的资源文件夹，因为是有道云笔记自动创建的文件夹，改名字之后他还会创建这个，所以就没有改名字）收集作为一个单独的分类，用于存放未进行整理的收集，有道云笔记生成的我的资源这个文件夹下，会根据你使用的插件，自动生成对应来源的子文件夹，比如来自网页剪报、微信收藏等，我新建了一个 思绪万千 文件夹，用于保存突发的想法。 2、 备忘 顾名思义，备忘分类用于一些需要查找使用，但又不需要完全记忆的内容，比如待办事项，待读书单，还有一些琐碎的文本数据备份等。 3、 工作 工作分类下面主要是记录一些业务需求，工作难点以及工作技巧。 4、 学习 主要是一些关于编程相关的子分类文件夹，这里和工作分类都因人而异。 5、 生活 生活分类主要放一些生活中学习的内容，比如读书笔记、投资指南，保险相关的知识。其实这个分类和学习分类很像，因为我关于代码的笔记比较多，所以将其他和代码不相关的笔记放在生活分类当中。 需要注意的是，分类的层级不宜嵌套太深，最好保持在三层以内，超过后不利于查找。(所以我把与代码不相关的放到生活分类下) 标签再谈笔记的标签，既然标签是对分类的一种补充，因此是非必要的，同时标签不能和分类重复，参考添加这些标签。 文章来源 （知乎、简书、CSDN等） 关键词 （笔记的关键点，可以提取几个词语出来作为标签） 不要太具体 （太具体就会导致标签过多，反而不利于标签的使用） 后言最后说说记笔记的原则 记笔记是为了用，不用的笔记没有任何价值 不能只收集不学习 定期回顾，整理与归档（定期回顾有利于笔记内容的记忆） 记笔记会遇到的一些问题？ 强迫症犯了，不知道该放在哪个分类下面， 原则是用，你认为放在哪个分类下面最可能被用到，就放在那个分类下面。 Nullpointer的博客 参考 https://www.zhihu.com/search?type=content&amp;q=%E7%AC%94%E8%AE%B0","tags":[{"name":"笔记","slug":"笔记","permalink":"http://nullpointer.pw/tags/笔记/"}]},{"title":"Mysql行转列输出【实战】","date":"2017-10-09T14:44:58.000Z","path":"Mysql行转列输出【实战】.html","text":"在很多场景下，需要将一行一行的数据转换成一列数据。比如每个人的每个科目都有一个分数，并分别对应一个分数，但是为了更加直观地看到一个人的所有科目成绩，所以需要将每个科目成绩由行转换成列。 原始数据 id stuid name subject score 1 110 xiaoA 语文 99 2 110 xiaoA 数学 88 3 112 xiaoB 语文 69 4 112 xiaoB 数学 100 行数据转换成列数据之后 stuid name 语文 数学 110 xiaoA 99 88 112 xiaoB 69 100 1234SELECT stuid, `name`, MAX(CASE `subject` WHEN 'C001' THEN score ELSE 0 END) as '语文', MAX(CASE `subject` WHEN 'C002' THEN score ELSE 0 END) as '数学'FROM `sys_user` GROUP BY stuid; 以下通过两个在工作中遇到的实例，来使用 Mysql 的行转列。 实例实例一网站进行推广，每个推广员都有一个唯一 ID 即 pid，现在要统计每个推广员的推广数据；需要统计推广过来的新增用户，以及新增用户的充值以及消费数据。这里简化了数据，便于理解。 数据说明： create_time： 数据生成时间 pid： 推广员唯一ID type： 数据类型 1： 新增用户 2： 新增充值 3： 新增消费 value： 对应的数据值 需求结果样式： SQL 查询： 1234567SELECT create_time,MAX(CASE type WHEN 1 THEN value ELSE 0 END) '新增用户',MAX(CASE type WHEN 2 THEN value ELSE 0 END) '新增充值',MAX(CASE type WHEN 3 THEN value ELSE 0 END) '新增订阅'FROM wings_companion_analytics GROUP BY create_time 实例二统计网站单本书的购买次数以及购买金额 数据说明： id： 主键 bookId： 书的 ID task_id： 数据类型 706： 购买次数 707： 购买金额 time： 数据生成时间 value： 对应的数据值 需求结果样式： SQL 查询： 12345678SELECT bookId as '作品ID', DATE_FORMAT(time,'%Y-%m-%d') as '日期', MAX(CASE task_id WHEN 706 THEN `value` ELSE 0 END) AS '购买次数', MAX(CASE task_id WHEN 707 THEN `value` ELSE 0 END) AS '购买金额'from `t_task_result_day`WHERE task_id IN (706, 707)GROUP BY time, bookIdORDER BY bookId, time; 资源下载 点我下载实例所用数据 参考 http://blog.csdn.net/wulantian/article/details/52687640 http://blog.csdn.net/u013938484/article/details/50552747","tags":[{"name":"mysql","slug":"mysql","permalink":"http://nullpointer.pw/tags/mysql/"},{"name":"行转列","slug":"行转列","permalink":"http://nullpointer.pw/tags/行转列/"},{"name":"实战","slug":"实战","permalink":"http://nullpointer.pw/tags/实战/"}]},{"title":"Nginx缓存配置之手动清除缓存","date":"2017-09-10T22:15:36.000Z","path":"Nginx缓存配置之手动清除缓存.html","text":"前言 前文介绍了利用 nginx 的 nginx_ngx_cache_purge 模块来实现缓存功能，并设置了缓存时间为一天。 但是如果前端修改了页面，比如首页，由于 Nginx 缓存的存在，网站首页并不会立即生效，而是要等到缓存过期。这样明显不是我们想要的结果，所以需要进行手动使 Nginx 缓存失效。以下为操作详解。 基础环境 已经设置缓存的 Nginx 服务器， 参照我之前博文 Nginx缓存配置 Nginx 配置文件拆分在企业 Nginx 应用中，Nginx 配置文件应该根据域名不同来进行拆分，然后在 nginx.conf中进行include引入。这样的好处是便于管理配置文件，便于修改配置文件， 而 nginx.conf 文件中只保留 upstream 以及其他通用配置信息。 在 Nginx 的 conf 目录下创建文件夹 include， 用于保存拆分的配置文件。 1mkdir include 拆分的规则可以如下： 桌面版（WEB）的 Nginx 配置文件，可以命名为 nginx_web.conf 手机版（WAP）的 Nginx 配置文件，可以命名为 nginx_wap.conf 安卓的 Nginx 配置文件，可以命名为 nginx_apk.conf 苹果的 Nginx 配置文件，可以命名为 nginx_ios.conf 清除缓存的配置文件，可以命名为 purge.conf 在 /usr/local/nginx/conf/nginx.conf 中引入拆分的配置文件， 在配置文件中的 http 节点下进行引入 123456789101112http&#123; #...... # 注意 purge.conf 必须要第一个引用！！！ include include/purge.conf; # 引入其他配置文件 include include/nginx_web.conf; #include include/nginx_wap.conf; #include include/nginx_apk.conf; #include include/nginx_ios.conf;&#125; 配置缓存清除12345678910111213141516171819cd /usr/local/nginx/conf/includevi purge.conf#purge.conf 文件内容为：server &#123; listen 80; server_name 192.168.200.129;# 此处我配置的是本机ip charset utf8; location ~ /purge(/.*) &#123; allow all;# 访问此接口的白名单，all代表所有人都可以访问该路径 # tmpcache 为前文中 proxy_cache_path 里配置的 keys_zone 的值 # www.domain.com$1$is_args$args 表示缓存key的名称，清除某一域名下的缓存,可以指定参数 # $1 代表正则匹配中的第一组 proxy_cache_purge cachefile www.domain.com$1$is_args$args; &#125;&#125;# 保存 purge.conf 文件 测试清除缓存如果要进行缓存清除，首先需要有缓存文件，此处参照前文 Nginx缓存配置 中，访问 www.domain.com/testpage2 ，刷新页面，直到缓存已经生成，即 X-Cache 的状态为 HIT。 进入 cd /tmp/cache/ ，查看已经生成了缓存文件 mark 123456# 测试 nginx 配置是否正确/usr/local/nginx/sbin/nginx -t# 如果提示 is ok，说明配置没有问题，否则需要修改# 重启 Nginx/usr/local/nginx/sbin/nginx -s reload 浏览器访问（也可以通过 curl 命令来访问）： 1234# 清除key为 www.domain.com/ 的缓存192.168.200.129/purge/ # 清除 key 为 www.domain.com/testpage2 页面缓存192.168.200.129/purge/testpage2 如果返回 则表示清除成功。 资源下载示例nginx配置文件","tags":[{"name":"nginx","slug":"nginx","permalink":"http://nullpointer.pw/tags/nginx/"},{"name":"缓存","slug":"缓存","permalink":"http://nullpointer.pw/tags/缓存/"}]},{"title":"为什么我们会感觉到倦怠?","date":"2017-09-04T14:14:00.000Z","path":"为什么我们会感觉到倦怠？.html","text":"为什么产生倦怠？刚开始 接手新项目、学习新技能时，我们总是兴奋不已、踌躇满志、迫不及待地想大展身手。但是过了不久，新鲜感退却后，大部分热情就会消退，最终就会兴趣索然，积极性低，进展缓慢或者毫无进展。 这样的事情很多，比如： 刚开始学习驾驶，是不是很兴奋？过了多久之后，就不再真正关心你的车了？多久以后，你已经觉得它已经“老”了？ 雄心勃勃地想锻炼出一副好身材，办了健身卡后，去了几次之后就再没去过了？ …… 我们当开始倦怠，于是我们半途而废，努力寻找新事物，找回自己真正的激情。 开始的时候我们的兴趣最高，而动机在开始阶段可能不高，但是随着取得进展，我们的动机水平开始上升。早期的成功让你感觉到有动力，冲量则推动你前进。 但是随着时间的推移，缓慢的成果进展在不断消耗你的动机，最终会发现动机和兴趣都濒临谷底，这就是那堵墙，也就是我们感觉倦怠的原因。 但是如果我们穿过了这道墙，我们的动机、兴趣会随着成果的不断取得而不断上升加强，最终我们获得了最大的回报，只是能够穿过这道墙的人很少。 如何穿过这道墙？制定一个目标或计划，采取“定额工作法”，并坚决按照计划完成定额工作。 首先需要确立一个目标，规定自己要在预定确定的时间段内需要取得多大的进展。 比如： 每周跑步 3 次 每周写一篇博客 每天看半小时的书 每天弹半小时的吉他 将所有重复性工作的频率进行量化，有的一月一次，有的一周3次，有的则是每天两次。并承诺完成，无论刮风下雨。 承诺是定额工作法的核心，除了想方设法完成自己的工作，不给自己留下任何其他的选择。 失败不能被接受，因为你让自己失信一次，就会有第二次，很快定额在你眼中就会变得一文不值。 定额工作法的优点还可以帮你克服意志力薄弱的问题。通过预先设定好的必须要遵循的过程，消除需要作出决策的部分。 即不需要做判断——你知道必须要做，只需要遵从命令，避免了意志力耗尽的问题。","tags":[{"name":"读书","slug":"读书","permalink":"http://nullpointer.pw/tags/读书/"}]},{"title":"Nginx缓存配置","date":"2017-08-20T08:09:08.000Z","path":"Nginx缓存配置.html","text":"前言 本文介绍利用 nginx 的 nginx_ngx_cache_purge 模块来实现缓存功能，前几篇文章介绍了 Nginx 的动静分离以及 CDN 技术，在其基础上，再对整个页面进行缓存，将大大提高服务器的负载能力。 基础环境 CentOS 6.8 minimal Nginx 1.12.1 ngx_cache_purge-2.3 环境搭建Nginx 与 nginx_ngx_cache_purge 下载解压 安装 wget 1yum install wget 下载 Nginx 1wget http://nginx.org/download/nginx-1.12.1.tar.gz 解压 Nginx 到 /usr/local/src/ 目录 1tar -zxvf nginx-1.8.1.tar.gz -C /usr/local/src/ 下载 ngx_cache_purge 1wget http://labs.frickle.com/files/ngx_cache_purge-2.3.tar.gz 解压到 Nginx 同一级目录 1tar -zxvf ngx_cache_purge-2.3.tar.gz -C /usr/local/src/ 目录结构为123---/usr/local/src --nginx-1.8.1 --ngx_cache_purge-2.3 进入 Nginx 解压目录1cd nginx-1.8.1 安装必要依赖1yum -y install gcc pcre-devel openssl openssl-devel 检查安装环境,并指定将来要安装的路径和要安装的插件1./configure --prefix=/usr/local/nginx/ --with-http_realip_module --add-module=../ngx_cache_purge-2.3 参数说明：–prefix： 将 nginx 安装到此目录–with-http_realip_module 启用获取用户真实 IP 模块–add-module=../ngx_cache_purge-2.3 添加 ngx_cache_purge 模块，用于缓存 进行编译安装1make &amp;&amp; make install 编译完成后，没有出现 error 为编译安装成功 设置 Nginx 缓存编辑 nginx.conf 配置文件1vi /usr/local/nginx/conf/nginx.conf 添加如下配置 12345678910111213141516171819202122232425262728293031# 需要在 /tmp 目录下创建 cache 文件夹！#设置缓存区的名称为 tmpcache，内存缓存空间大小为 200MB，1 天没有被访问的内容自动清除，硬盘缓存空间大小为 5GB， 如果访问频率不高的话， inactive 时间可以设置长一些。proxy_cache_path /tmp/cache levels=1:2 keys_zone=tmpcache:200m inactive=1d max_size=5g;server &#123; listen 80; server_name www.domain.com;#你的域名 charset utf8; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Up-Calling-Line-Id $http_x_up_calling_line_id; proxy_ignore_headers X-Accel-Expires Expires Cache-Control Set-Cookie; access_log logs/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080; #proxy_cache 的值是 proxy_cache_path 中的 keys_zone 的值 proxy_cache tmpcache; #缓存 key 的值 proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 301 5m; proxy_cache_use_stale updating error timeout invalid_header http_500 http_502 http_503 http_504; expires 1m; # 将缓存的状态添加到 Header 中 add_header X-Cache '$upstream_cache_status'; &#125;&#125; 启动 Nginx1/usr/local/nginx/sbin/nginx 启动 Tomcat可以使用自己的项目，或者使用我提供的项目来进行测试。 1wget http://ojt4b2cr5.bkt.clouddn.com/SpringDemo.war 将下载的 war 包放到 Tomcat 的 webapps 目录下，修改 war 包名称为 ROOT.war ，启动 Tomcat。 测试 Nginx 缓存缓存之前 查看 /tmp/cache 目录， 目录下面没有任何文件 修改本机（windows）的 hosts 文件，将配置的域名指向服务器 IP 1192.168.200.129 www.domain.com 打开浏览器访问 www.domain.com/testpage1 发现 X-Cache 的状态为 MISS ，说明没有缓存。 再次刷新页面后 X-Cache 的状态已经变成了 HIT 同时在服务器上查看 /tmp/cache 目录 cd /tmp/cache/ 发现该目录下面已经多了文件目录，进去之后打开文件，发现正是刚刚访问页面的源码，说明 Nginx 的缓存已经配置成功了。只要是配置的域名下面的页面， 如果没有进行过滤，都会缓存到服务器。当第二次访问的时候，请求经过 Nginx 服务器时，Nginx 直接返回已经缓存的静态页面，这样将大大降低应用服务器 Tomcat 的负载。 需要注意的是：并不是该域名下的所有页面都需要进行缓存，如果缓存有误，会出现很严重的问题。比如不正确的将域名下的用户中心进行了缓存，当其他用户也进入页面的时候，显示的全部都是第一个进入该页面用户的信息。因此建议做缓存时，最好根据域名来做， 根据用户不同显示不同的页面的地址就不要做缓存。当然，如果接口地址规范，亦可以通过 Nginx 正则匹配路径的方式，只将某些匹配的路径做缓存。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://nullpointer.pw/tags/nginx/"},{"name":"缓存","slug":"缓存","permalink":"http://nullpointer.pw/tags/缓存/"}]},{"title":"阿里云CDN实现网站文件动静分离","date":"2017-08-19T23:21:04.000Z","path":"阿里云CDN实现网站文件动静分离.html","text":"前言上一篇文章介绍了如何利用 Nginx 来实现静态资源请求与动态请求的分离，虽然不是所有的请求都压到 Tomcat 应用服务器，但是静态资源请求还是都会到 主机上给主机带来压力，因此本文通过利用阿里云的 CDN 技术来更加彻底地降低应用访问的负载。 配置静态资源域名建立一个只用于请求静态资源文件的二级域名，将动态请求与静态请求分离开。 比如静态资源请求的域名是 res.domain.com ， 动态请求的域名是 www.domain.com 配置 Nginx 静态资源设置参考我的上一篇文章 Nginx动静分离 阿里云 CDN 配置登录阿里云 CDN 控制台，添加域名。 需要注意的是资源文件只需要放到一台主机上即可，方便管理。 添加 CDN 域名成功后，回到域名管理页面， 在域名列表中找到新加的域名，光标悬浮到该域名上，会出现一个 复制 CNAME 的按钮，选择复制，会得到一个类似于 res.domain.com.w.kunlunle.com 的域名。 DNS 配置进入你的域名的 DNS 服务提供商控制台，我这里是 DNSPOD ， 找到静态资源域名，我的是 res.domain.com 修改记录类型为 CNAME ，记录值修改为上一步复制的 域名，如 res.domain.com.w.kunlunle.com。 选择保存，等待几分钟 DNS 生效后，访问域名试试吧！ 比如我的 res.domain.com/_res/a.jpg （需要事先在资源服务器上事先放置该静态文件） 如果访问不到说明配置有误或者缓存还未生效。这里有一个坑就是，自己的电脑有可能因为缓存没刷新访问不到该路径静态资源，而别人的电脑可以，可以换一台电脑尝试访问，或者通过手机浏览器访问尝试。 End。","tags":[{"name":"动静分离","slug":"动静分离","permalink":"http://nullpointer.pw/tags/动静分离/"}]},{"title":"Nginx动静分离","date":"2017-08-19T09:44:23.000Z","path":"Nginx动静分离.html","text":"前言最新公司新开了一个项目，项目由我来配置基础环境，会写一系列的教程来展示，一个网站从零到上线的整个过程。首先本文介绍资源文件的隔离。 为什么要实现动静分离为什么要将静态资源文件与动态请求进行分离？ 为了降低 Tomcat 服务器的负载，可以通过本文设置并结合 CDN 来实现来更彻底地降低服务器的负载。 如图所示，所有的请求都压到了同一台服务器上， 无论静态还是动态的请求，这样流量大的话势必会造成服务器的负载过高，因为动静分离是必不可少的。 环境介绍首先这是我们项目的目录结构， resource 目录和 _res 目录中都是静态资源文件，存放比如 js/css/img 等资源。这两个目录下的文件有所不同，_res 目录下面是压缩版本的，比如压缩的js/css。通过 Git 或者 SVN 将项目上传到服务器上后，配置 Nginx 来完成静态资源的分离。 首先看一张图(图的来源是：http://www.cnblogs.com/xiaoblog/p/4241086.html) 当请求经过 Nginx 时，如果是静态资源的请求，就直接返回主机上静态资源即可， 如果是动态请求，则去请求 Tomcat 服务器后再返回。如果流量不是很大，静态资源可以和 Tomcat 服务器放在同一台主机上，否则需要将静态资源与 Tomcat 服务器分开。 我司对于资源文件的做法是新建一个二级域名，该域名只用于加载静态资源文件。如 res.domain.com，这样做的好处是简化了在 Nginx 的 配置。 配置 Nginx首先需要安装 Nginx， 可以参考我的另外一篇文章 Nginx实现Tomcat集群。这里只需要参考到安装 Nginx 即可。 Nginx 静态资源配置 打开 Nginx 配置文件 vim /usr/local/nginx/conf/nginx.conf 添加 server 1234567891011121314151617181920212223242526272829303132333435server &#123; # 只接收静态资源请求 listen 80; server_name res.domain.com; charset utf8; default_type text/plain; add_header Access-Control-Allow-Origin *; #access_log logs/heiyan.image.access.log click; location ~* \\.(zip|rar|gz|tar.gz|gz|exe)$ &#123; return 500; &#125; location / &#123; #资源文件的目录 root /home/resources; index index.html; expires 30d; default_type text/plain; &#125;&#125;server &#123; # 接收动态请求 listen 80; server_name www.domain.com; charset utf8; access_log logs/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080; &#125;&#125; 拷贝项目中资源文件到指定的资源目录在 Nginx 的配置文件中指定了资源文件的目录为 /home/resources ，所以需要将资源拷贝到该目录下，进入上文下载的项目的目录中，将资源目录（我这里是_res目录)拷贝到 /home/resources目录下面。 cp -rf _res /home/resources 拷贝完成后的目录应该是： /home/resources/_res 在 /home/resources/_res 目录下放一张图片 a.jpg ，用于测试。 测试静态资源获取启动 Nginx 打开浏览器访问： http://res.domain.com/_res/a.jpg 如果是动态请求，则使用 http://www.domain.com 域名 返回结果： 因为静态资源文件包含 css/js 等文件，修改提交后需要拷贝增量与修改的文件到 /home/resources 目录下，如果嫌麻烦，可以直接在 Nginx 配置文件中，配置 路径为项目的资源文件夹根路径，比如 /home/wide-api/src/main/java/resources/_res， 这种在更新代码之后，可以直接请求到新的资源文件。之后会写一篇通过阿里云CDN来完成静态分离。 注： 由于我的是在虚拟机上的 Nginx 进行测试，也没有域名，且是minimal版本系统，没有桌面环境，所以需要配置宿主机的hosts， 在宿主机的浏览器中访问。在真实服务器且有自己绑定到服务器上域名的就直接测试即可。 使用 SwitchHosts 软件 配置 hosts，我的虚拟机 ip 为192.168.200.129 1192.168.200.129 www.domain.com res.domain.com","tags":[{"name":"nginx","slug":"nginx","permalink":"http://nullpointer.pw/tags/nginx/"},{"name":"动静分离","slug":"动静分离","permalink":"http://nullpointer.pw/tags/动静分离/"}]},{"title":"CentOS快速安装","date":"2017-08-18T23:40:27.000Z","path":"CentOS快速安装.html","text":"前言最近学习过程中需要使用到 Linux 系统，但是并没有服务器，因此通过虚拟机来完成。本文不从头开始介绍虚拟机的安装，只讲解 虚拟机自制镜像 备份的快速还原，如果你需要从头开始安装的，请另寻教程。本文中涉及的镜像会提供下载地址，以供参考。 学习过程中安装虚拟机时总是会遇到一些需要花费大量时间才能解决的问题，比如不能联网、数据库连接不上、ssh 连接不了等问题，为了便于学习，本人将安装好的系统导出为镜像文件，以后如果需要添加虚拟机时，直接还原镜像修改部分配置即可，以下为教程。 环境准备 虚拟机软件 VMware® Workstation 11 系统镜像版本 CentOS 6.8 minimal (命令行版本，无桌面) 自定义镜像以及VMware下载 链接：http://pan.baidu.com/s/1nuKxhpf 密码：8dt8若链接失效，发邮件给我补链接 联系我 VMware 配置需要安装的虚拟机采取 NAT 方式联网，因此 需要在 VMware 中配置网关地址。 打开虚拟网络编辑器，设置子网 IP 点击 NAT 设置，设置网关地址IP （网关相当于一个路由器），注意网关 IP 要和子网 IP 处于同一个网段。如192.168.200.x 导入镜像文件依次选择菜单， 文件–&gt;打开–&gt; 找到下载镜像解压的文件夹，选择192.168.200.129.ovf 文件 设置虚拟机名称和虚拟机保存路径，选择导入。 稍等一会儿导入成功后，开启虚拟机。 虚拟机网络配置登录账号：root 密码：123456 刚安装完是无法 ping 通外网的，需要修改网络配置， 当前镜像已经设置了静态 ip，便于使用。 修改 70-persistent-net.rules 文件 vi /etc/udev/rules.d/70-persistent-net.rules 注释掉 eth0 所在行，结果应该为：1234# PCI device 0x8086:0x100f (e1000)#SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR&#123;address&#125;==\"00:0c:29:30:a4:b5\", ATTR&#123;type&#125;==\"1\", KERNEL==\"eth*\", NAME=\"eth0\"# PCI device 0x8086:0x100f (e1000)SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR&#123;address&#125;==\"00:0c:29:cd:05:ea\", ATTR&#123;type&#125;==\"1\", KERNEL==\"eth*\", NAME=\"eth1\" 修改网络配置文件，设置静态IP地址和网关地址vi /etc/sysconfig/network-scripts/ifcfg-eth0 1234567891011DEVICE=eth1 # 修改eth0 为eth1TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.200.132 # 修改为想要的静态ip地址， 如果网关地址为192.168.100.2 则ip地址为 192.168.100.x x为1-254，且不与网关地址重复GATEWAY=192.168.200.2 # 修改为你虚拟机的网关地址 IPNAME=\"System eth0\"NETMASK=255.255.255.0DNS1=8.8.8.8DNS2=4.4.4.4 重启虚拟机 reboot 这是必须的步骤！ 检验是否修改生效 重启登录成功后， 输入 ip addr， 如果你显示的和我一致，则是正确的。 如果你的出现了两条 inet， 说明第 1 步， 和第 2 步没有配置正确。此时 ping 一下百度，发现已经可以 ping 通了。 至此，虚拟机已经配置好了。可以通过 SSH 软件进行连接了。 建议：虚拟机安装完成后，对其进行快照，防止弄坏了还需要重新安装。 在快照管理器中，可以选择保存的快照，还原到快照时的系统。","tags":[{"name":"centos","slug":"centos","permalink":"http://nullpointer.pw/tags/centos/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://nullpointer.pw/tags/虚拟机/"}]},{"title":"Java之word导出下载","date":"2017-07-27T14:12:07.000Z","path":"Java之word导出下载.html","text":"前言最近遇到项目需求需要将数据库中的部分数据导出到 word 中，具体是在一个新闻列表中将选中的新闻导出到一个 word 中。参考了网上一些教程，实现了该功能，在此记录下来。 导出结果如下： 图中为导出的其中两条新闻。 搜索网上导出 word 的方式有很多种，但是很多都是一笔带过，有示例代码的只找到了 POI 导出，和通过 FreeMarker 方式导出，但是只是具有参考意义。本文采取使用 FreeMark 方式。 实现步骤 Maven 工程引入FreeMarker 的依赖，非 Maven 工程添加 jar 包 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt;&lt;/dependency&gt; 创建 word 模板 新建 word 替换内容为占位符 另存模板为 XML 文件 使用 NotePad++ 打开 xml 文件 选中全部内容，到这里进行格式化 将原内容替换为格式化后的内容 因为我的 word 的内容是一个列表，所以需要添加一个 freemarer 标签标识 找到&lt;w:document&gt; 元素下面的 &lt;w:body&gt; 元素，添加&lt;#list newsList news&gt; ， 并在&lt;/w:body&gt;结束标签之前闭合 &lt;/#list&gt;， 此处的 newsList 为后台读取模板时需要需要渲染数据map集合的key， 其所对应的是一个list集合。 替换模板中的占位符 &lt;w:t&gt;${news.title}&lt;/w:t&gt; 与 &lt;w:t&gt;${news.content}&lt;/w:t&gt; 为遍历集合的值，这里的 FreeMarker 语法可以参考网上的教程。 保存为 FreeMarker 的模板文件，后缀为 ftl 格式，拷贝到项目中 编写代码 从数据中查询数据集合放入Map中， 调用工具方法，返回流 12345Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;();root.put(\"newsList\", newsList);//newsList为新闻对象集合String template = \"/temp.ftl\"; //模板文件的地址ByteArrayOutputStream outputStream = WordUtil.process(root, template);return outputStream; 调用下载工具类进行下载即可。 1DownloadUtil.download(byteArrayOutputStream, response, returnname); 注：在实现功能的时候，由于采取的是 ajax 请求方式，导致只是将流写入 Response 时， Response 为 xml 格式的数据。但是想要实现的效果是弹出下载框，下载 word 文档。最后查询资料，修改ajax请求为form表单提交方式(ajax form)，才弹出下载框实现了功能。 文章涉及工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//WordUtil.javaimport java.io.BufferedWriter;import java.io.ByteArrayOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.Map;import freemarker.template.Configuration;import freemarker.template.Template;public final class WordUtil &#123; private static Configuration configuration = null; private WordUtil() &#123; throw new AssertionError(); &#125; /** * 根据模板生成相应的文件 * @param root 保存数据的map * @param template 模板文件的地址 * @param path 生成的word文档输出地址 * @return */ public static synchronized ByteArrayOutputStream process(Map&lt;?, ?&gt; root, String template) &#123; if (null == root ) &#123; throw new RuntimeException(\"数据不能为空\"); &#125; if (null == template) &#123; throw new RuntimeException(\"模板文件不能为空\"); &#125; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); String templatePath = template.substring(0, template.lastIndexOf(\"/\")); String templateName = template.substring(template.lastIndexOf(\"/\") + 1, template.length()); if (null == configuration) &#123; configuration = new Configuration(Configuration.VERSION_2_3_23); // 这里Configurantion对象不能有两个，否则多线程访问会报错 configuration.setDefaultEncoding(\"utf-8\"); configuration.setClassicCompatible(true); &#125; configuration.setClassForTemplateLoading(WordUtil.class, templatePath); Template t = null; try &#123; t = configuration.getTemplate(templateName); Writer w = new BufferedWriter(new OutputStreamWriter(outputStream, \"utf-8\")); t.process(root, w); // 这里w是一个输出地址，可以输出到任何位置，如控制台，网页等 w.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return outputStream; &#125;&#125; 1234567891011121314151617181920212223242526272829//DownloadUtil.javaimport java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletResponse;import org.apache.commons.io.FileUtils;public class DownloadUtil &#123; /** * @param byteArrayOutputStream 将文件内容写入ByteArrayOutputStream * @param response HttpServletResponse 写入response * @param returnName 返回的文件名 */ public static void download(ByteArrayOutputStream byteArrayOutputStream, HttpServletResponse response, String returnName) throws IOException&#123; response.setContentType(\"application/msword\"); response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + returnName); response.setContentLength(byteArrayOutputStream.size()); OutputStream outputstream = response.getOutputStream(); //取得输出流 byteArrayOutputStream.writeTo(outputstream); //写到输出流 byteArrayOutputStream.close(); //关闭 outputstream.flush(); //刷数据 &#125;&#125; 源码下载点我下载 参考链接 http://itindex.net/detail/55080-springboot-freemarker-%E6%A0%BC%E5%BC%8F","tags":[{"name":"word","slug":"word","permalink":"http://nullpointer.pw/tags/word/"},{"name":"freemarker","slug":"freemarker","permalink":"http://nullpointer.pw/tags/freemarker/"}]},{"title":"Java配置分离之Spring远程配置","date":"2017-07-16T01:14:30.000Z","path":"Java配置分离之远程配置.html","text":"前言集群应用的配置文件如果写在项目的 resources 目录下面，当遇到需要修改某一个配置值时，需要将集群的所有应用的配置信息进行修改，并且将机密的配置信息比如数据库账号密码如果不进行加密配置在项目中很危险，一旦发生代码泄露问题，后果很严重。 为了避免上述情况发生，将配置信息存储到数据库中，比如数据库连接、用户名、以及密码，通过 Config 项目的一个接口提供获取配置信息。Config 项目只用于读取配置信息。 远程配置一）新建类 RemoteProperties 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;public class RemoteProperties implements InitializingBean, FactoryBean&lt;Properties&gt; &#123; private String url = null; private Properties properties = new Properties(); @Override public Properties getObject() throws Exception &#123; return properties; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return properties.getClass(); &#125; @Override public boolean isSingleton() &#123; return true; &#125; @Override public void afterPropertiesSet() throws Exception &#123; loadProperty(); &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; private void loadProperty() &#123; if (StringUtil.strIsNull(url)) return; String content = HttpClientUtil.urlGet(url); JSONObject object = JSONObject.parseObject(content); JSONArray data = object.getJSONArray(\"datasource\"); for (Object obj : data) &#123; JSONObject jsonObject = (JSONObject) obj; String key = obj.getString(\"key\"); String value = obj.getString(\"value\"); properties.put(key, value); &#125; &#125;&#125; 此类用于发送请求获取配置信息，请求返回格式为 JSON 的配置信息, 如：1234567891011121314151617181920&#123; \"datasource\":[ &#123; \"value\":\"com.mysql.jdbc.Driver\", \"key\":\"jdbc.driver\" &#125;, &#123; \"value\":\"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8\", \"key\":\"jdbc.url\" &#125;, &#123; \"value\":\"root\", \"key\":\"jdbc.username\" &#125;, &#123; \"value\":\"root\", \"key\":\"jdbc.password\" &#125; ]&#125; 二）编写 Spring 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;bean id=\"propertyConfigurerUserServer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"properties\"&gt; &lt;bean id=\"remoteProperties\" class=\"com.craft.partner.server.util.RemoteProperties\" p:url=\"http://api.xxx.com/config\"/&gt; &lt;!--远程配置提供接口--&gt; &lt;/property&gt; &lt;!--还可以加载本地的properties文件--&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:configure.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\" p:driverClass=\"$&#123;jdbc.driver&#125;\" p:jdbcUrl=\"$&#123;jdbc.url&#125;\" p:user=\"$&#123;jdbc.username&#125;\" p:password=\"$&#123;jdbc.password&#125;\"&gt; &lt;property name=\"initialPoolSize\" value=\"10\" /&gt; &lt;property name=\"minPoolSize\" value=\"10\" /&gt; &lt;property name=\"maxPoolSize\" value=\"50\" /&gt; &lt;property name=\"maxStatements\" value=\"0\" /&gt; &lt;property name=\"maxIdleTime\" value=\"600\" /&gt; &lt;property name=\"idleConnectionTestPeriod\" value=\"300\" /&gt; &lt;property name=\"acquireIncrement\" value=\"5\" /&gt; &lt;property name=\"autoCommitOnClose\" value=\"true\" /&gt; &lt;property name=\"checkoutTimeout\" value=\"2000\" /&gt; &lt;/bean&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"find*\" read-only=\"true\" /&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt;&lt;!--其他不符合规范的方法只允许读操作--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config expose-proxy=\"false\"&gt; &lt;aop:pointcut id=\"serviceMethod\" expression=\"execution(* com.craft.partner.server.service.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"serviceMethod\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 注意： 通过 p:url=”地址” 的方式，调用 RemoteProperties 的方法，发送请求获取配置信息，通过 Spring 进行注入。注入后，可以通过 p:属性 的方式获取配置。 参考 http://www.cnblogs.com/yjmyzz/p/how-to-load-remote-config-in-spring.html","tags":[{"name":"远程配置","slug":"远程配置","permalink":"http://nullpointer.pw/tags/远程配置/"}]},{"title":"基于机器学习的搜索推荐","date":"2017-05-26T23:08:14.000Z","path":"基于机器学习的搜索推荐.html","text":"公司以前搜索使用的是封装luncene代码，由于有索引，查询速度很快，但有不足之处，需要提高搜索的准确性。 前言笔者所在公司是一家小说公司，我们将小说的名称以及作者的名称生成索引便于搜索，但是通过分析用户访问日志发现，有一些用户会搜索章节名称，或者小说主人公名称或者某些指定关键字，但是这些并没有生成索引，因此无法搜索到。为了提高搜索准确性，最开始列出了几种方案:①针对每本书添加关键字并生成索引②对所有书的章节名称生成索引但是以上两种方案都不可取，第一种方案增加了我们公司编辑的工作量，并且效率低下效果也未必会好。第二种方案也不行，因为用户搜索的都是当下热门的作品，而对所有的作品的章节名称生成索引，无疑是一种空间浪费。最后，采取了阿里与的机器学习来完成搜索的相关匹配，在原有搜索结果的基础上，作为辅助选项，提高搜索的准确性。注:当用户即使未登录，对于服务器也有唯一标识，笔者公司使用的是nginx的 ngx_http_userid_module针对客户端生成的唯一标识，以下简称为uc。 主要步骤流程 ①读取最近三天的用户访问日志到一张ODPS表中 ②通过机器学习统计 1. 读取三天内的访问日志2. 将日志根据用户端(电脑版、手机版、安卓、IOS)拆分笔者公司的电脑版和手机版用户的访问路径类似，以下简称为路径一，安卓和IOS访问路径类似以下简称为路径二，所以如上图拆分日志。 3. 路径一和路径二的逻辑基本一致，只以路径一举例，路径二以下不再赘述** 4. 抽取路径一中的搜索访问日志例如http://search.xxx.com?queryString=E5%F3%7B%，可以使用正则匹配出，亦可以使用like匹配。1select * from $&#123;t1&#125; where url like '%queryString=%' 4.1. 提取搜索访问日志中的搜索关键字key与uc(客户端用户唯一标识)1SELECT uc, REGEXP_EXTRACT(url,'queryString=([^&amp;]+)',1) as keyword FROM $&#123;t1&#125; 4.2 对于uc与key进行去重1select uc, keyword from $&#123;t1&#125; where keyword &lt;&gt; '' group by uc, keyword 5. 抽取路径一种的用户章节购买日志1select * from $&#123;t1&#125; where url REGEXP '/book/(\\\\d+)/(\\\\d+).*$'; 5.1. 提取uc与作品ID1SELECT uc, REGEXP_EXTRACT(url, '/book/(\\\\d+)/(\\\\d+).*$',1) as book_id FROM $&#123;t1&#125; 5.2. 进行uc与bookId去重1select uc, book_id from $&#123;t1&#125; where book_id &lt;&gt; '' group by uc, book_id 6. 将路径一与路径二的结果进行合并(uc&amp;key结果合并 uc&amp;bookId结果合并 ) 7. 通过组件join进行连接 左表为uc&amp;key右表为uc&amp;bookId 通过第7步得到key与bookId的对应关系 ③通过ODPS SQL统计key&amp;bookId的出现次数1INSERT OVERWRITE TABLE search_book_count SELECT keyword, book_id, COUNT(*) AS count FROM search_book GROUP BY keyword, book_id ④将以上结果同步到RDS本地数据库中 ⑤进行查询时，将key&amp;bookId对应关系最多的五条记录作为搜索辅助结果即可。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://nullpointer.pw/tags/机器学习/"}]},{"title":"Java上传图片到OSS的实现","date":"2017-05-06T15:01:57.000Z","path":"Java上传图片到OSS的实现.html","text":"前言： 以前做项目用的都是开源的分布式系统，如FastDFS。最近几年，随着云的发展，国内外的巨头公司也相应的推出了相关商用的类似产品。比如Amazon S3，阿里云的OSS，腾讯云的COS。今天我选择使用阿里云的OSS来作为例子，来实现图片的上传。 准备工作阿里云OSS官方文档地址 一、开通阿里云OSS 登录阿里云控制台开通OSS服务，并创建AccessKeyId和AccessKeySecret 在OSS控制面板上新建Bucket 进入新建的Bucket选择左侧的Object管理，新建一个img的文件夹，便于存储归类 二、maven项目中引入依赖在maven工程中的pom.xml添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; 编写代码 注：我所使用的的框架是：SpringMVC+Spring+Mybatis 一、上传文件到OSS之HelloWorld上传图片之前，先惯例来一个HelloWorld示例！1234567891011121314151617181920212223242526272829303132333435363738394041import com.aliyun.oss.OSSClient;import com.aliyun.oss.model.ObjectMetadata;import com.aliyun.oss.model.PutObjectResult;import com.nullpointer.common.Constants;import com.nullpointer.service.AliyunOSSService;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import javax.annotation.PostConstruct;import java.io.File;import java.io.IOException;import java.io.InputStream;@Servicepublic class AliyunOSSServiceImpl implements AliyunOSSService &#123; public static final String IMG = \"img/\";//对应Object的文件夹名称 private static final int maxLength = 5 * 1024 * 1024;//简单上传OSS限制为5G以下 public static final String ENDPOINT = File.separatorChar == '/' ? \"oss-cn-hangzhou-internal.aliyuncs.com\" : \"http://oss-cn-hangzhou.aliyuncs.com\";//用于选择不同的域名 private OSSClient client; private static String bucketName; /** * 初始化OSSClient */ @PostConstruct public void init() &#123; String accessId = \"xxxxxxxxxxxxx\";//你的AccessId， 在OSS控制台可以生成 String accessKey = \"xxxxxxxxxxxxxxxxx\";//你的AccessKey bucketName = \"xxxxx\";//创建的Bucket的名称，注意要一致区分大小写 client = new OSSClient(ENDPOINT, accessId, accessKey);//初始化 &#125; public String uploadIm() &#123; String content = \"Hello OSS\"; PutObjectResult test01 = client.putObject(bucketName, \"test01\", new ByteArrayInputStream(content.getBytes())); return test01.getETag(); &#125;&#125; 打开OSS控制台的Object管理，是不是发现新增了一个文件呢？ 二、编写图片上传服务类HelloWorld示例完成了，开始正式编写图片上传代码了。注释都有。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Servicepublic class AliyunOSSServiceImpl implements AliyunOSSService &#123; public static final String IMG = \"img/\";//对应Object的文件夹名称 private static final int maxLength = 5 * 1024 * 1024;//简单上传OSS限制为5G以下 public static final String ENDPOINT = File.separatorChar == '/' ? \"oss-cn-hangzhou-internal.aliyuncs.com\" : \"http://oss-cn-hangzhou.aliyuncs.com\";//用于选择不同的域名 private OSSClient client; private static String bucketName; /** * 初始化OSSClient */ @PostConstruct public void init() &#123; String accessId = \"xxxxxxxxxxxxx\";//你的AccessId， 在OSS控制台可以生成 String accessKey = \"xxxxxxxxxxxxxxxxx\";//你的AccessKey bucketName = \"xxxxx\";//创建的Bucket的名称，注意要一致区分大小写 client = new OSSClient(ENDPOINT, accessId, accessKey);//初始化 &#125; /*public String uploadIm() &#123; String content = \"Hello OSS\"; PutObjectResult test01 = client.putObject(bucketName, \"test01\", new ByteArrayInputStream(content.getBytes())); return test01.getETag(); &#125;*/ @Override public String saveImage(MultipartFile file) &#123; try &#123; String fileName = this.saveImage(file.getSize(), file.getOriginalFilename(), file.hashCode(), file.getInputStream()); return getHttpUrl(fileName); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String getHttpUrl(String fileName) &#123; return Constants.OSS_HTTP + \"/\" + IMG + fileName; &#125; @Override public String saveImage(long size, String extName, int hashCode, InputStream is) &#123; if (size &gt; maxLength)//超过5G return null; String name = extName.toLowerCase(); name = name.substring(name.indexOf(\".\"));//获得上传文件的后缀名称如 .jpg String fileName = System.currentTimeMillis() + \"_\" + hashCode + name;//为了防止重复， 使用时间戳+hashcode的方式来命名 return this.saveImage(size, fileName, is); &#125; @Override public String saveImage(long size, String fileName, InputStream is) &#123; String key = IMG + fileName;//保存到img文件夹下 this.uploadObject(key, size, is); return fileName; &#125; @Override public void uploadObject(String key, long size, InputStream is) &#123; ObjectMetadata metadata = new ObjectMetadata();//设置文件的meta信息 metadata.setContentLength(size); metadata.setContentType(\"image/jpeg\"); PutObjectResult result = client.putObject(bucketName, key, is);//调用SDK的上传方法 System.out.println(result); &#125;&#125; 三、编写Controller层的上传接口123456789101112@RequestMapping(value = \"/upload\", method = RequestMethod.POST)public void uploadOSS(MultipartFile pic, HttpServletResponse response, Model model) throws Exception &#123; String imgUrl = aliyunOSSService.saveImage(pic); System.out.println(\"path = \" + imgUrl); //图片回显 JSONObject jsonObject = new JSONObject(); jsonObject.put(\"path\", imgUrl); response.setContentType(\"application/json;charset=UTF-8\"); response.getWriter().write(jsonObject.toString());&#125; 需要注意的是：入参中的MultipartFIle是一个接口，需要在Spring的配置文件applicationContext.xml中将其实现类注入。1&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"/&gt; 四、编写页面JSP12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;script src=\"/static/js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"/static/js/jquery.form.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;title&gt;home&lt;/title&gt; &lt;script type=\"application/javascript\"&gt; function uploadPic() &#123; var options = &#123; url: \"/upload\", type: \"POST\", dataType: \"json\", success: function (data) &#123; $(\"#imgUrl\").attr(\"src\", data.path); &#125; &#125; $(\"#jform\").ajaxSubmit(options); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container-fluid\"&gt; &lt;div class=\"row-fluid\" align=\"content\"&gt; &lt;form action=\"/uploadOSS\" method=\"POST\" id=\"jform\"&gt; &lt;div class=\"span12\"&gt; &lt;img alt=\"img\" class=\"img-polaroid\" id=\"imgUrl\"/&gt; &lt;input type=\"file\" name=\"pic\" onchange=\"uploadPic()\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 页面不是我所擅长，能显示效果即可。 五、测试图片上传启动项目，进入图片上传的页面。 上传图片控制台打印了如下内容： 页面显示：","tags":[{"name":"OSS","slug":"OSS","permalink":"http://nullpointer.pw/tags/OSS/"},{"name":"对象存储系统","slug":"对象存储系统","permalink":"http://nullpointer.pw/tags/对象存储系统/"}]},{"title":"Nginx实现Tomcat集群","date":"2017-05-05T14:12:54.000Z","path":"Nginx实现Tomcat集群.html","text":"本文介绍了利用nginx搭建了一个简单的负载均衡。 一、准备工作Linux系统: CentOS 7 x64 Nginx版本:1.12.0 Tomcat版本: 7.0.77 二、安装CentOS 快速安装，见我另外一篇文章CentOS快速安装安装Nginx依赖1234567891011# gcc 用来编译nginxyum install gcc-c++# PCRE nginx的http模块使用pcre来解析正则表达式yum -y install pcre*# zlib nginx使用zlib对http的内容进行gzip压缩yum install -y zlib zlib-devel# openssl https支持yum -y install openssl 下载Nginx1234# 安装wgetyum install wget# 下载nginxwget http://nginx.org/download/nginx-1.12.0.tar.gz 编译安装Nginx123456789# 解压nginxtar -zxvf nginx-1.12.0.tar.gz# 进入解压目录cd nginx-1.12.0./configure# 若无错误，可以执行以下安装makemake install# 默认安装到/usr/local/nginx目录 Nginx测试12345678910111213141516# 启动nginx/usr/local/nginx/sbin/nginx# 访问localhostwget localhost# 此命令会下载一个index.html文件vim index.html# index.html中有关于nginx的类似于helloworld语句# 由于我的Linux安装在虚拟机中，想要外部访问虚拟机内，需要关闭防火墙或开放端口# 编辑防火墙， CentOS 7默认的防火墙不是iptables，需要另行安装，请自行解决vim /etc/sysconfig/iptables# 添加80端口-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT# 重启防火墙service iptables restart# 通过本机的浏览器访问虚拟机的iphttp://192.168.243.127(此处为虚拟机的ip) 三、配置用于集群的Tomcat1234567891011121314151617181920212223242526# 下载Tomcatwget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.77/bin/apache-tomcat-7.0.77.tar.gz# 创建目录mkdir /usr/local/tomcats# 解压Tomcattar -zxvf apache-tomcat-7.0.77.tar.gz -C /usr/local/tomcats# 修改解压的Tomcat目录名称mv apache-tomcat-7.0.77 tomcat1# 为了测试nginx负载均衡,需要对tomcat的server.xml配置一下vim tomcat1/conf/server.xml# 显示行号:set nu# 在105行修改为如下， 并保存退出&lt;Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"jvm1\"&gt;# 修改示例程序echo 'tomcat1:&lt;%=session.getId()%&gt;' &gt; tomcat1/webapps/ROOT/index.jsp# 拷贝tomcat1目录为tomcat2cp -r tomcat1 tomcat2# 修改tomcat2的server.xml中的端口号vim tomcat2/conf/server.xml# 修改22行/71行/93行的端口# 修改105行&lt;Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"jvm2\"&gt;# 修改示例程序echo 'tomcat2:&lt;%=session.getId()%&gt;' &gt; tomcat1/webapps/ROOT/index.jsp 四、配置Nginx1vim /usr/local/nginx/conf/nginx.conf 启动tomcat123# 启动两个tomcat./tomat2/bin/startup.sh./tomat1/bin/startup.sh 测试外部访问虚拟机 http://192.168.243.127(此处为虚拟机的ip) 多刷新几次，可以看到页面的内容在变化，在tomcat1和tomcat2之间进行切换，至此完成了简单nginx负载均衡的搭建。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://nullpointer.pw/tags/nginx/"},{"name":"tomcat","slug":"tomcat","permalink":"http://nullpointer.pw/tags/tomcat/"}]},{"title":"《聪明人都用方格笔记本》读书笔记","date":"2017-01-22T10:08:00.000Z","path":"《聪明人都用方格笔记本》读书笔记.html","text":"2017年读的第一本书，读完了一直没有写读书笔记，拖延到今天，才勉强写完。中途看到《如何有效阅读一本书》，就一起读了，学学读书笔记的写法。 此书主要讲了笔记本对于笔记的影响，好的笔记本让笔记发挥它应有的功能，而不好的笔记本体现不出笔记的价值所在。作者以三个著名机构使用的笔记本为例，列举了方格笔记本的种种益处，并通过配图的方式，让读者一目了然地了解方格笔记本记录笔记的方式。 书名 作者 开始时间 结束时间 聪明人都用方格笔记本 高桥政史 2017.01.01 2017.01.04 将方格笔记本“分为三部分”记录。从左向右依次将笔记本分为三部分，按照“事实→解释→行动”的顺序记录笔记。 一）笔记本的区别1. ☆笔记本的对比 使头脑变聪明的笔记本 阻碍能力发挥的笔记本 对比 看起来工整 第一印象给人脏乱的感觉，使人不愿再看第二眼 理解力、积极性低下 比A4纸大 比A6纸小、记事本型 思考复杂问题的能力、逻辑思维能力低下 颜色不超过三种 用了四种以上的颜色 判断优先顺序的能力、判断力低下 每一页都有一个主题 这也写、那也写 舍弃能力、整理能力低下 是黑板、白板板书内容的提炼 照抄黑板、白板板书 记忆力、独立思考能力低下 留有空白区域 无空隙，写得满满当当 理解能力、复习能力低下 画有许多图、表、画 无图、表、画，只有文字 视觉把握能力、表现力低下 日后看笔记时依然可再现当时的内容 日后看笔记时无法再现当时的内容 学习能力、理解力低下 2. ★好与坏的笔记本的区别好笔记本看上去一目了然，能够迅速把握重点，复现记笔记时的场景；而坏笔记就是让你根本没有看的欲望，即使是看了，也不能提取有效内容，大多数情况下，坏笔记本的作用就是没有作用。 二）记笔记的目的1. ☆记笔记的误区不管你参加的是多么优秀的培训、讲座、研讨，如果你的笔记无法再现当时的学习内容，那么，你好不容易学到的知识、技巧化为乌有的可能性将很大。 笔记的生命线是“再现性”，这是记笔记的最终目的。 可是，没有学习过笔记本使用方法的人日后再看自己的笔记时，只能看到上面的词语和句子，却回忆不出“为何需要这些信息”“这些信息有什么作用”这些更为重要的部分。 也就是说，他们用的是缺乏再现性的记笔记法。 为什么要做笔记？ 我是怕日后忘记才记的 我只是照抄板书罢了 我有记笔记的习惯 2. ★记笔记需要克服的困难作者说，抱着以上这几种目的而做笔记的人需要变化记笔记的方式，应当停止当前这种记笔记的方法。一直以来，记了很多笔记，但是我每次记完的笔记只是当成了备忘，把笔记本当成了字典。 需要使用以前记过的笔记的时候，就借助个人良好的分类习惯查找对应的笔记，以及借助软件的全文检索功能查找我所需要的笔记。 长而久之，便养成了依赖的习惯，记笔记记完也只是在脑海中保留一份关键字，而内容却一概忘记，这恐怕是我的记笔记方式的最大弊病，再现笔记的内容是个人需要克服的难点。 三）框架·黄金三分法1. ☆谁采取了这种框架 康奈尔笔记本分为“Note”（板书）、“Queue”（发现点）、“Summary”（总结）三部分。 东大录取生中的大多数学生将笔记本的左右两页作为一页使用，左侧记录“板书”，右侧写“发现点”和“总结”，和康奈尔笔记本的构造完全相同。 麦肯锡公司的“空·雨·伞”，埃森哲公司的“Point Sheet”，所有外资管理咨询公司的咨询顾问都是按照“事实→解释→行动”的三分法展开思考的。 2. ☆框架的组成 内容 对应 板书 事实 发现 解释 总结 行动 3. ★框架的使用步骤 摘抄原文：加深对原文的印象 提出问题，做出解释：基于原文进行思考，并给出结果 进行总结：对于整篇文章的总体概述 按照黄金三分法来做笔记，可以提高笔记对知识的再现性，知名机构都采取的是黄金三分法这种框架来做笔记。 四）笔记本的结构1. ☆笔记本的方向人的思考会受到眼睛构造的左右，所以进入视野的是“纵向”框架还是“横向”框架，能够影响人们的理解速度以及对信息的把握程度。 在把握整体情况时，需要解决的问题越复杂、参考的信息量越庞大，就越需要在短时间内迅速抓住重点。 随着学习、工作层次的提升，“既见树木，又见森林”这一思考方式的重要性也就更为突显。 2. ☆笔记本的大小“不善于提炼想法”“很难按逻辑性思维思考”“不会言简意赅地表达”的原因是什么？ 笔记本的大小意味着思考能力的强弱。 3. ☆笔记的颜色用黑色或蓝色书写笔记，用红色作为判断，也就是遇到非常重要或需要修改的地方时使用红色。 用此种简单方法区分使用颜色的话，便会在记笔记的同时自然舍弃掉无用的内容，将思考重点放在主要问题上，养成判断主次先后的习惯，逐步提高解决问题的速度和质量。 颜色最多用三种。 只要能做到这一点，事后再翻看笔记时，仅看颜色就能立刻区分出主次顺序，记笔记时的思路也能在大脑中清晰重现，进一步提升信息整理和输出的效率。 4. ☆笔记标题区域的利用通常会在笔记本上部的空白区域写入论点和结论。以解决工作问题的笔记本为例，“论点=问题的核心是什么”“结论=这样做便可以解决问题”。 5. ★笔记本结构对于笔记的影响 笔记采取横向结构，可以起到一目了然的作用，参考的文章信息便于提取到大脑中。 小笔记本不利于总结想法，来回地翻页会打断思考的书写。因此使用大笔记本来记笔记。 太多的颜色会导致找不到重点，处处是重点的情况， 合理标记标题，梳理核心内容，有助于快速理解笔记内容。 五）笔记本的功能1. ☆记忆性笔记本上课、研讨或是要记忆、理解学习内容时记录的笔记，为了记在脑子里而写的笔记。本书将这类笔记本称为“学习笔记本”。 2. ☆思考性笔记本为看出事物本质、理解重点、得出结论而写的笔记，常见于工作中。本书将这类笔记本称为“工作笔记本”。 3. ☆传达性笔记本传达性笔记即能够从丰富的信息中筛选出对方所需的改善策略及解决方法，为了说服对方而写的笔记。本书将写这类笔记的笔记本称为“提案笔记本”或“博弈笔记本”。 4. ★不同功能笔记本对的记法作者的这本书所描述的黄金三分法最适合于做思考性笔记，而对于记忆性笔记本的记法，采取这种方式，也能起到一定加深印象的作用。对于传达性笔记本而言，既列出事实，又给出合理解释，也是不错的方式。 六） 提高笔记本的作用1. ☆能形成“永久记忆”的用眼方法如果你之前是一边看着老师在黑板上写下的内容，一边原封不动地抄写在笔记本上的话，那么，请你改变一下抄写笔记时的“用眼方法”吧！ 将此前：×“看黑板→写笔记”的记录方法改为： “看黑板→印在大脑中→不看黑板，将印在大脑中的内容重现在笔记本上”。 不是一边看黑板一边抄写，而是在“看黑板→抄写”之间加入“印在大脑中的一秒钟”。 我把这一秒钟称为“空白的一秒钟”。 只需要这一秒钟，你的笔记本就能升级成能使大脑越变越聪明的笔记本。 2. ★方法的效果在抄写的这一步骤中加入映入大脑，可以加深对所抄写内容的记忆。 记得以前在背日语单词时，采取的就是这种方法，看一下单词，然后闭上眼睛，让单词在脑海中浮现出来，效果比直接抄写到本上的方法要好。 3. ☆逻辑连接词的种类与用途 4. ★连接词的效果找到适合自己的逻辑连接词，将思考进行流程化。（在中部区域使用） 5. ☆三个箭头的使用 6. ☆两个能力的实质 提问能力 概括能力 所谓“提问能力”，就是得到某个信息后并不会直接一口吞下，而是会提出类似“这到底是什么意思”“为什么会这么说”之类问题的能力。 所谓“概括能力”，就是能看透事物本质，并且将梳理后的重点内容记在脑子里，然后简单明了地讲给别人听。 7. ★两个能力的作用如何应用学习的知识，是由这两个能力来决定。这两个能力的提高与每天的脑力训练是密不可分的，只有不断地联系，逐渐强化，这二者的能力对于个人的提升就会越发明显。 8. ☆不要让你的笔记本变得代谢不良“代谢不良笔记本”是不分有用信息和无用信息、什么都往上写的、不进行整理总结的“阻碍能力发挥的笔记本”的典型例子。 如果这也记、那也记的话，那么不知不觉中，笔记本中的“结论和论点”就会变得模糊，什么是“该舍弃的无用信息”，什么是“应该留下的重点内容”，也会变得难以区分。 “这也记、那也记”“先记下再说”“说不定以后会用到”……按照这样的想法记笔记的话，记在笔记上的信息日后被使用的概率几乎为零。 9. ★代谢不良笔记本的坏处如果什么都记、也不进行整理总结，这样记录的笔记只是摘抄罢了，就像中学时使用的摘抄本， 如果不对摘抄进行分类，不时常去翻看，摘抄的内容是不会被完整地存储到记忆当中。","tags":[{"name":"读书","slug":"读书","permalink":"http://nullpointer.pw/tags/读书/"}]},{"title":"《如何有效阅读一本书:超实用读书笔记法》读书笔记","date":"2017-01-15T12:37:00.000Z","path":"《如何有效阅读一本书：超实用读书笔记法》读书笔记.html","text":"买完Kindle读的第三本书，作者的观点部分适用于现在的我，可能是由于环境的不同（作者在日本）。作者提倡使用纸质笔记本来记录读书笔记，但是对于一个出门不喜欢背包的人来说，这很muli~原文对于如何选书、购书说了很多，对于如何记笔记的内容不太多，不过，还是很有参考价值。 书名 作者 开始时间 结束时间 如何有效阅读一本书：超实用读书笔记法 奥野宣之 2017.01.11 2017.01.15 一、购书 ☆只有从日常生活中取材，才能列出反映自己真正需求的购书清单。 ★ 书单内容来源于生活，可能是别人的推荐、也可能是宣传、或者自己脑海中蹦出的关键词。收集这些内容，这样到了书店，在书海中就不会茫然若失，不知道想要买些什么样的书了。有目的地逛书店，买自己想要的书 二、如何做读书笔记1)坚持做读书笔记☆ 2013年8月5日，我读了《XXXX》。这本书比我想象中有意思。 如果写得这样简单，就更容易坚持下去了.第一步要做到的就是坚持下去，毫不夸张地说，只有坚持下去，读书笔记才能发挥作用。读书时应该时刻记得这个目的，正确地对待写读书笔记这件事。 人们经常说“你为别人讲解书中的内容时，才会真正理解它。”把记读书笔记作为目标去读书，得到的效果也是一样的。当你以思想输出为前提去读书时，思想输入的质量也会有所提升，而且亲手写文章的好处比口头叙述要多。 ★ 刚开始学习做读书笔记时，不必苛刻自己要做得多么好，总结得多么妙，最开始的时候，最重要的是培养自己做读书笔记的习惯。读书笔记主要是对自己读书的一种总结，吸收书中的精华，而并非是为了他人而写。 2)读书笔记从一句话开始☆ 书写这一动作，也有整理自己想法的含义。 举个例子，读完冒险题材的纪实文学以后，就会想在读书笔记里写上“这个人真厉害”。你拿起笔时，会想到。等一下，不写上这个人是哪里厉害、为什么厉害的话，下次再读到这句话时会看不懂吧”，于是你会这样写作者的体力和精神承受力都太强了。普通人在失明后一定会感到绝望，就算他比一般人强壮，在这样的环境下也很难生还。为什么作者可以如此坚强? 本来只想写一句话，却把自己的感受一股脑儿地写了下来，并由此展开思考，读书笔记就这样充实了起来。 ★ 一篇上万字的文章也是从一句话开始的，上百万字的小说可能也只是通过一份不过千字的大纲逐渐扩展而来。不怕写不出一万字的长文，只怕连一句最最简单的话都不写。 3)无法坚持做笔记的原因☆ 需要注意的是，千万不要为了坚持写读书笔记而走形式主义。不管采用什么方式，都要踏实地写笔记，并真正理解书的内容。 ★ 并非如作者所说，我们不可能真正理解所有读过的书的内容，但是写笔记一定要踏实地去做便是。 三) 做笔记的步骤1) 针对纸质书 ★ 刚开始认为这样是对于书的一种不爱护的表现，现在才觉得其实这么做的方式并没有多么不好，前提是书的主人是自己。与其看过一遍就扔掉或者再也不看；不如让看过的书留下自己读过的痕迹，更好的吸收书中的内容。 2) 针对电子书Kindle★ 以下针对Kindle的部分为个人总结，书中并未提及。 1.通读:把读起来觉得不错的那一页的中间部分的两个字加入笔记、笔记内容为1（1只是做的一个标记） 由于Kindle在添加笔记时会同时插入一条笔记和一条标注记录、所以需要删除标记那条记录。删除第一条记录、保留笔记内容为1的记录。 2.重读读完一遍之后，再把笔记列表中的几页重新读一遍。如果仍然觉得很好，添加书签 3.标记再重新读一遍加有书签的几页，如果第三次阅读后仍然觉得值得一读，就用标记功能在上面做记号。最后留下来的就是你认为最有用的部分了。这一页上会有通读步骤的笔记记录、有重读步骤加的书签、有标记步骤时划的标记。 可以通过Kindle Mate这个软件将标记的内容导出来，便于做读书笔记。读书笔记可以用有道云笔记，个人使用有道云的Markdown做笔记，如果想保存Kindle电子书中的图片，可以按住左下角和右上角进行截图，会自动保存，连接电脑后Kindel所在盘的根目录可以找到。 四)葱鲔[wěi]锅式读书笔记☆ 葱鲔火锅式读书笔记=摘抄+评论写读书笔记之前注意的三个事项: 写读书笔记的日期 书名 作者名 除了以上三个要素、也可以加上以下两个要素。 对自己来说重要的内容（摘抄） 自己对这篇文章的感想（评论） 步骤: 写上日期，每次换行都要留一行空白，而每个段落之间留两行空白，便于日后重读、插入文字和更正修改。 摘抄和写评论，重读做过记号的内容，严格筛选出自己认为可以多读几遍的部分、最后在摘抄完的文章后面留出一些空白，写上自己的评论。摘抄部分用☆表示，而用自己语言表达的感想和补充说明则标上★以此作为区分，交替标在每个段落前。 五)示例【080715】《决定人类未来的50件事》/杰西卡·威廉姆斯/草思社 ☆自杀者中有三分之二是因为抑郁。(P180) ★作者说，世界上的自杀者比在战争中死去的人还要多。人类在战争平代会死亡，在和平年代也会死亡，真是不容易。 ☆所谓奴隶，就是被剥夺了人权的人。即使是这样，奴隶社会中也存在对待奴隶人性化的情况，奴隶们在饥饿或者生病的时候是可以不工作的。但在现代社会、奴隶就是一次性的财产，被贱买贱卖。 ★以前的奴隶是长期雇佣制，而现在的则是因为抵押贷款而被人身买卖。为了事后不留麻烦，奴隶们被送去做合同工或零工，被任意驱使。一个人活在世上，最不可或缺的到底是人权还是金钱呢? “☆”。后面是摘抄。注意不要省略，要保持原汁原味。 “★”后面则是自己的评论，写一些对摘抄内容的感想 并非所有的书都要按照这种方法，所以我们要根据对作品的重视程度改变笔记的写法 比如像“文件整理技巧”一类的纯实用技巧书、可以不去摘抄，而是只标记“★”并总结要点。如果是小说等休闲读物，可以直接分条书写自己对这本书的感想。 六)寻找最具代表性的语句 ☆ 只有让自己感动的段落才值得摘抄，一定是摘抄让自己心动的语句。 另一方面，选择摘抄段落时，不是找让人觉得“理应如此”的文章，而是觉得“这么一说确实有道理”的内容。 读过一本书以后，对书中内容感同身受固然让人心情愉悦，但这也代表这次读书没有给你带来新东西。相反，如果一篇文章颠覆了你之前的想法，使你的认识发生动摇，在抄写和重读的过程中仍然会让人信服或是感觉震撼，这种文章才是值得摘抄的。 七)激发思想的火花☆ 在摘抄的同时，附上自己的感想和思考，把作者的话和自己的话放在一起，感受落差。好主意不会凭空出现。不论是什么想法，都一定是对某种刺激做出的回应。只有在读完书后对书中内容做出反应，进行主动思考，才能真正掌握这本书的内容。 两个概念 “吸取精华”:原封不动地吸取书上的知识。 “读书体验”: ● “书上写的这些，我是这么理解的” ● “以此为契机，我想到了一件事……” ★ 没有主动思考的阅读，书中的内容被掌握的极其有限，甚至于未读过一样。","tags":[{"name":"读书","slug":"读书","permalink":"http://nullpointer.pw/tags/读书/"}]},{"title":"点击按钮拷贝代码的实现","date":"2016-10-09T06:33:00.000Z","path":"点击按钮拷贝代码的实现.html","text":"例子： 1、 head中引入一个js clipboard.js 1&lt;script src=\"//cdn.bootcss.com/clipboard.js/1.5.15/clipboard.js\"&gt;&lt;/script&gt; 2、初始化对象 123&lt;script type=\"text/javascript\"&gt; new Clipboard('.btn');//此处btn是copy按钮的id&lt;/script&gt; 3、使用copy 1234567&lt;div class=\"col-lg-6 col-md-8 col-sm-8\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"murl\" value=\"$&#123;murl&#125;\" /&gt;&lt;/div&gt;&lt;button type=\"button\" class=\"btn\" data-clipboard-target=\"#murl\" &gt;复制&lt;/button&gt;&lt;!-- data-clipboard-target 要复制的目标--&gt; 参考 http://clipboardjs.52fhy.com/","tags":[{"name":"JS","slug":"JS","permalink":"http://nullpointer.pw/tags/JS/"}]},{"title":"Ons消息队列","date":"2016-10-02T04:17:00.000Z","path":"Ons消息队列.html","text":"Ons消息队列前引：公司项目需要写一个推广系统，推广系统是一个项目，和主项目分离，项目间的通信使用Ons来完成，以下是公司代码略微修改的结果，以供参考。 术语： Producer：消息生产者，负责产生消息，一般由业务系统负责产生消息。 Consumer：消息消费者，负责消费消息，一般是后台系统负责异步消费。 Producer ID：一类 Producer 的集合名称，这类 Producer 通常发送一类消息，丏发送逻辑一致。 Consumer ID：一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，丏消费逻辑一致。 广播消费：一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer ID，消息也会被 Consumer ID中的每个 Consumer 都消费一次，广播消费中的 Consumer ID 概念可以讣为在消息划分方面无意义。 集群消费：一个 Consumer ID 中的 Consumer 实例平均分摊消费消息。 例如某个 Topic 有 9 条消息， 其中一个 ConsumerId 有 3 个实例（可能是 3 个进程，或者 3 台机器） ，那么每个实例只消费其中的 3 条消息 引入依赖 Maven方式 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun.openservices&lt;/groupId&gt; &lt;artifactId&gt;ons-client&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; jar包方式 http://onsall.oss-cn-hangzhou.aliyuncs.com/aliyun-ons-client-java.tar.gz 一、发送消息1、在阿里云控制台的消息队列中配置 Topic、Producer ID， Consumer ID2、创建Ons消息生产者1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class ProducerService implements IProducerService &#123; private Producer producer; @Override public void sendMessage(String topic, String tag, String content) &#123; try &#123; byte[] bytes = content.getBytes(\"UTF-8\"); Message msg = new Message(topic, tag, bytes); SendResult sendResult = producer.send(msg); System.out.println(\"SendMessageIng... topic:\" + topic + \" tag:\" + tag + \" \"+ sendResult); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; @PostConstruct public void init() &#123; Properties properties = new Properties(); //PropertyKeyConst 是Ons官方定义的常量 //需要在阿里云控制台创建 AccessKey，SecretKey properties.put(PropertyKeyConst.ProducerId, ProducerConstants.PRODUCERID_PCHOME); //PRODUCERID_PCHOME是在控制台配置Topic 的 Producer ID properties.put(PropertyKeyConst.AccessKey, ProducerConstants.ACCESSID); properties.put(PropertyKeyConst.SecretKey, ProducerConstants.ACCESSKEY); producer = ONSFactory.createProducer(properties); // 在发送消息前，必须调用start方法来启动Producer，只需调用一次即可。 producer.start(); &#125; @PreDestroy public void destory() &#123; // 在应用退出前，销毁Producer对象 // 注意：如果不销毁也没有问题 producer.shutdown(); &#125;&#125; 3、创建发送消息类1234567891011121314151617181920212223242526272829import net.minidev.json.JSONObject;import com.aliyun.openservices.ons.api.Action;import com.aliyun.openservices.ons.api.ConsumeContext;import com.aliyun.openservices.ons.api.Message;import com.aliyun.openservices.ons.api.MessageListener;@Servicepublic class OnsService implements IOnsService, MessageListener &#123; @Resource private IProducerService producerService; public static final String TOPIC = \"TopicTestONS\"; public static final String TOPIC_TAG = \"TagA\"; @Override public Action consume(Message message, ConsumeContext context) &#123; return null; &#125; @Override public void sendBindObject(int uid, int tid, int eid, String pageUrl) &#123; JSONObject json = new JSONObject(); json.put(\"uid\", uid); json.put(\"tid\", tid); json.put(\"eid\", eid); json.put(\"pageUrl\", pageUrl); producerService.sendMessage(TOPIC, TOPIC_TAG, json.toJSONString()); //第三个参数就是需要发送的内容，公司使用的Json &#125;&#125; 二、订阅消息1、创建Ons消息消费者1234567891011121314151617181920212223242526272829303132@Service@Lazy(value=false)public class ConsumerService implements IConsumerService &#123; private Consumer consumer; @PostConstruct public void init() &#123; System.out.println(\"init....\"); Properties properties = new Properties(); properties.put(PropertyKeyConst.ConsumerId, ConsumerConstants.CONSUMERID); properties.put(PropertyKeyConst.AccessKey,ConsumerConstants.ACCESSID); properties.put(PropertyKeyConst.SecretKey,ConsumerConstants.ACCESSKEY); properties.put(PropertyKeyConst.MessageModel,PropertyValueConst.CLUSTERING); consumer = ONSFactory.createConsumer(properties); consumer.start(); &#125; //MessageListener 是阿里Ons包内的消息监听器 @Override public void subscribe(final String topic, final String subExpression, final MessageListener listener) &#123; consumer.subscribe(topic, subExpression, listener); &#125; @PreDestroy public void desotry() &#123; if (consumer != null) &#123; consumer.shutdown(); &#125; &#125;&#125; 2、创建消费消息类123456789101112131415161718192021222324@Servicepublic class OnsConsumerService implements IOnsConsumerService &#123; @Resource private IConsumerService consumerService; public static final String TOPIC = \"TopicTestONS\"; @PostConstruct public void init() &#123; System.out.println(\"starting...\"); onsConsumerService.subscribe(TOPIC, \"*\", new MessageListener() &#123; @Override public Action consume(Message message, ConsumeContext context) &#123; JSONObject parse = (JSONObject) JSONValue.parse(message.getBody()); int uid = JsonUtil.getInt(parse, \"uid\"); int tid = JsonUtil.getInt(parse, \"tid\"); int eid = JsonUtil.getInt(parse, \"eid\"); String pageUrl = JsonUtil.getString(parse, \"pageUrl\"); System.out.println(uid + tid + eid + pageUrl); return Action.CommitMessage; &#125; &#125;); &#125;&#125; 以上为Ons的集群订阅消息代码。 参考： Ons官方文档 http://onsteam.oss-cn-hangzhou.aliyuncs.com/ALIYUN_ONS_USER_GUIDE.pdf","tags":[{"name":"Ons","slug":"Ons","permalink":"http://nullpointer.pw/tags/Ons/"},{"name":"消息队列","slug":"消息队列","permalink":"http://nullpointer.pw/tags/消息队列/"}]}]